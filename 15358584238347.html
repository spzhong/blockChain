<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  一篇对比特币脚本的理解 - 我对区块链的理解
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="我对区块链的理解" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>

<link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermaid.css">
<!--        <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermadidstyle.css">-->
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/jquery.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/rawdeflate.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/encode64.js"></script>
            <script src="asset/sample-custom-html-charts/echarts.common.min.js"></script>
            <script src="asset/sample-custom-html-charts/mermaid.min.js"></script>
            <script type="text/javascript">
                $(function(){
                  var mwebii=0;
                  var mwebChartEleId = 'mweb-chart-ele-';
                  $('pre>code').each(function(){
                                     mwebii++;
                                     var eleiid = mwebChartEleId+mwebii;
                                     if($(this).hasClass('language-mermaid')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div id="'+eleiid+'"></div>').addClass('mermaid').html($(this).text()).insertAfter(ele);
                                     }else if($(this).hasClass('language-plantuml')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     var str = unescape(encodeURIComponent($(this).text()));
                                     var imgURL = "http://www.plantuml.com/plantuml/svg/"+encode64(deflate(str,9));
                                     var newEle = $('<div id="'+eleiid+'"><img src="'+imgURL+'" /></div>').insertAfter(ele);
                                     }else if($(this).hasClass('language-js-echarts')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div style="width: 100%;height:400px;" id="'+eleiid+'"></div>').insertAfter(ele);
                                     var myChart = echarts.init(document.getElementById(eleiid));
                                     try  {
                                     eval($(this).text());
                                     myChart.setOption(option);
                                     }catch(exception) {}
                                     }
                                     });
                  
                  mermaid.init({noteMargin: 10}, ".mermaid");
                  });
                </script>



  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">首页</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        <li id=""><a target="_self" href="about.html">关于</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 我对区块链的理解</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">首页</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        
        <li><a target="_self" href="about.html">关于</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="poofAlgorithm.html">共识算法</a></li>
        
            <li><a href="about.html">关于</a></li>
        
            <li><a href="index.html">指引</a></li>
        
            <li><a href="bit.html">比特币</a></li>
        
            <li><a href="ethereum.html">以太坊</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>一篇对比特币脚本的理解</h1>
     
        <div class="read-more clearfix">
          <span class="date">2018/9/2</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='bit.html'>比特币</a></span>
           
         
          <span class="comments">
            
              <a href="15358584238347.html#disqus_thread">comments</a>
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p>在比特币交易的理解中，我们简单的介绍了脚本及脚本语言是如何运行的，那么这篇文章我具体的讲讲脚本的类型用法，及扩展</p>

<ul>
<li>
<a href="#toc_0">1.比特币脚本的特点及基本语法</a>
<ul>
<li>
<a href="#toc_1">脚本的本质</a>
</li>
<li>
<a href="#toc_2">脚本的常见关键字字段</a>
</li>
<li>
<a href="#toc_3">脚本的流控制关键字字段</a>
</li>
<li>
<a href="#toc_4">其它重要的字段说明</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">2.比特币脚本支付有哪些类型</a>
<ul>
<li>
<a href="#toc_6">付款到公钥哈希</a>
</li>
<li>
<a href="#toc_7">多重签名</a>
</li>
<li>
<a href="#toc_8">付款到脚本P2SH</a>
<ul>
<li>
<a href="#toc_9">P2SH地址</a>
</li>
<li>
<a href="#toc_10">P2SH的优点</a>
</li>
<li>
<a href="#toc_11">赎回脚本和标准确认</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">如何存储数据到区块链上</a>
<ul>
<li>
<a href="#toc_13">多重签名</a>
</li>
<li>
<a href="#toc_14">数据记录输出（OP_RETURN操作符）</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_15">3.时间锁</a>
<ul>
<li>
<a href="#toc_16">交易锁定时间</a>
</li>
<li>
<a href="#toc_17">检查锁定时间验证</a>
</li>
<li>
<a href="#toc_18">相对时间锁</a>
<ul>
<li>
<a href="#toc_19">nSequence相对时间锁</a>
</li>
<li>
<a href="#toc_20">带CSV的相对时间锁</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">中位时间过去Median-Time-Past</a>
</li>
<li>
<a href="#toc_22">针对费用阻击（Fee Sniping）的时间锁定</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">4.具有流量控制的脚本（条件字句）</a>
<ul>
<li>
<a href="#toc_24">VERIFY操作码的条件字句</a>
</li>
<li>
<a href="#toc_25">在脚本中使用流控制</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">5.复杂的脚本的运用</a>
<ul>
<li>
<a href="#toc_27">一个case</a>
</li>
<li>
<a href="#toc_28">case问题解答</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.比特币脚本的特点及基本语法</h2>

<p>比特币在交易中使用的脚本系统，于FORTH（一种编译语言）一样，脚本是简单的，基于堆栈的，并且是从左向右处理的，特意设计成非图灵完整的形式，没有LOOP（循环）语句</p>

<h3 id="toc_1">脚本的本质</h3>

<p>实际上脚本本质上是众多指令的列表，交易上的脚本本质是也是输入和输出的入栈的操作指令，使得操作指令False表示0，True表示非0</p>

<h3 id="toc_2">脚本的常见关键字字段</h3>

<table>
<thead>
<tr>
<th>关键字</th>
<th>操作码</th>
<th>十六进制</th>
<th>输入</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>OP_0</td>
<td>0</td>
<td>0x00</td>
<td>无</td>
<td>空</td>
<td>一个字节空串被推到栈中（并非no-op操作，这里有一个元素被压入堆栈中）</td>
</tr>
<tr>
<td>N/A</td>
<td>1-75</td>
<td>0x01-0x4b</td>
<td>特殊</td>
<td>数据</td>
<td>下一个操作码字节被压入堆栈的数据</td>
</tr>
<tr>
<td>OP_PUSHDATA1</td>
<td>76</td>
<td>0x4c</td>
<td>特殊</td>
<td>数据</td>
<td>下一个字节被压入堆栈的数据的长度</td>
</tr>
<tr>
<td>OP_PUSHDATA2</td>
<td>77</td>
<td>0x4d</td>
<td>特殊</td>
<td>数据</td>
<td>下两个字节被压入堆栈的数据的长度</td>
</tr>
<tr>
<td>OP_PUSHDATA4</td>
<td>78</td>
<td>0x4e</td>
<td>特殊</td>
<td>数据</td>
<td>下四个字节被压入堆栈的数据的长度</td>
</tr>
<tr>
<td>OP_1NEGATE</td>
<td>79</td>
<td>0x4f</td>
<td>无</td>
<td>-1</td>
<td>数字-1被压入堆栈</td>
</tr>
<tr>
<td>OP_1</td>
<td>81</td>
<td>0x51</td>
<td>无</td>
<td>1</td>
<td>数字1被压入堆栈</td>
</tr>
<tr>
<td>OP_2-OP_16</td>
<td>82-96</td>
<td>0x52-0x60</td>
<td>无</td>
<td>2-16</td>
<td>关键名对应的数字被压入栈</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">脚本的流控制关键字字段</h3>

<table>
<thead>
<tr>
<th>关键字</th>
<th>操作码</th>
<th>十六进制</th>
<th>输入 / 输出</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>OP_NOP</td>
<td>97</td>
<td>0x61</td>
<td>无</td>
<td>无任何操作</td>
</tr>
<tr>
<td>OP_IF</td>
<td>99</td>
<td>0x63</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>如果栈顶元素值不为0，则语句将被执行，栈顶元素将被删除</td>
</tr>
<tr>
<td>OP_NOTIF</td>
<td>100</td>
<td>0x64</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>如果栈顶元素值为0，则语句将被执行，栈顶元素将被删除</td>
</tr>
<tr>
<td>OP_ELSE</td>
<td>103</td>
<td>0x67</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>如果前述的OP_IF或OP_NOTIF或OP_ELSE未被执行，那么这些语句就会执行，如果执行了，则表示这些语句不会被执行</td>
</tr>
<tr>
<td>OP_ENDIF</td>
<td>104</td>
<td>0x68</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>结束if/else语言块</td>
</tr>
</tbody>
</table>

<h3 id="toc_4">其它重要的字段说明</h3>

<p>脚本的字段关键字有好些，有些操作码已被禁入，我们主要了解一些关键的及常用的字段就可以了。</p>

<table>
<thead>
<tr>
<th>关键字</th>
<th>操作码</th>
<th>十六进制</th>
<th>输入</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>OP_VERIFY</td>
<td>105</td>
<td>0x69</td>
<td>TRUE/FALSE</td>
<td>无/FALSE</td>
<td>如果栈顶原色值非真，则标记交易无效，TRUE会被删除，FALSE不会删除</td>
</tr>
<tr>
<td>OP_RETUEN</td>
<td>106</td>
<td>0x6a</td>
<td>无</td>
<td>无</td>
<td>标记交易无效</td>
</tr>
<tr>
<td>OP_IFDUP</td>
<td>115</td>
<td>0x73</td>
<td>--</td>
<td>--</td>
<td>如果栈顶元素不为0，则复制该元素值</td>
</tr>
<tr>
<td>OP_DROP</td>
<td>117</td>
<td>0x75</td>
<td>--</td>
<td>--</td>
<td>删除栈顶元素</td>
</tr>
<tr>
<td>OP_DUP</td>
<td>118</td>
<td>0x75</td>
<td>--</td>
<td>--</td>
<td>复制栈顶元素</td>
</tr>
<tr>
<td>OP_SWAP</td>
<td>124</td>
<td>0x7c</td>
<td>--</td>
<td>--</td>
<td>栈顶的两个元素交换</td>
</tr>
<tr>
<td>OP_2DROP</td>
<td>109</td>
<td>0x6d</td>
<td>--</td>
<td>--</td>
<td>删除栈顶的两个元素</td>
</tr>
<tr>
<td>OP_2DUP</td>
<td>110</td>
<td>0x6e</td>
<td>--</td>
<td>--</td>
<td>复制栈顶的两个元素</td>
</tr>
<tr>
<td>OP_EQUAL</td>
<td>135</td>
<td>0x87</td>
<td>x1 x2</td>
<td>true/false</td>
<td>如果输入的两个数相等，则返回1，否则返回0</td>
</tr>
<tr>
<td>OP_EQUALVERIFY</td>
<td>136</td>
<td>0x88</td>
<td>x1 x2</td>
<td>true/false</td>
<td>与OP_EQUAL一样，之后运行OP_VERIFY</td>
</tr>
<tr>
<td>OP_RIPEMD160</td>
<td>166</td>
<td>0xa6</td>
<td>in</td>
<td>hash</td>
<td>输入用RIPEMD-160算法散列</td>
</tr>
<tr>
<td>OP_SH256</td>
<td>168</td>
<td>0xa8</td>
<td>in</td>
<td>hash</td>
<td>输入用HAS-256算法散列</td>
</tr>
<tr>
<td>OP_HASH160</td>
<td>169</td>
<td>0xa9</td>
<td>in</td>
<td>hash</td>
<td>输入两次散列哈希，先用SHA-256,再用RIPEMD-160</td>
</tr>
<tr>
<td>OP_HASH256</td>
<td>168</td>
<td>0xa8</td>
<td>in</td>
<td>hash</td>
<td>输入两次SHA-256</td>
</tr>
<tr>
<td>OP_CHECKSIG</td>
<td>172</td>
<td>0xac</td>
<td>sig pubkey</td>
<td>true/false</td>
<td>全部交易的输出，输入和脚本都被散列，使用的签名必须是该Hash值和公钥的有效签名，返回1或0</td>
</tr>
<tr>
<td>OP_CHECKSIGVERIFY</td>
<td>173</td>
<td>0xad</td>
<td>sig pubkey</td>
<td>true/false</td>
<td>与OP_CHECKSIG一样，但之后执行OP_VERIFY</td>
</tr>
<tr>
<td>OP_CHECKMULTISIG</td>
<td>174</td>
<td>0xae</td>
<td>x sig1 sig2 ... number of signatures pub1 pub2 number of public of public keys</td>
<td>true/false</td>
<td>多重签名</td>
</tr>
<tr>
<td>OP_CHECKMULTISIGVERIFY</td>
<td>175</td>
<td>0xaf</td>
<td>x sig1 sig2 ... number of signatures pub1 pub2 number of public of public keys</td>
<td>true/false</td>
<td>与OP_CHECKMULTISIG一样，但之后执行OP_VERIFY</td>
</tr>
<tr>
<td>OP_VERIF</td>
<td>101</td>
<td>0x65</td>
<td>--</td>
<td>--</td>
<td>交易无效，即使发生在未执行的OP_IF分支</td>
</tr>
<tr>
<td>OP_VERNOTIF</td>
<td>102</td>
<td>0x66</td>
<td>--</td>
<td>--</td>
<td>交易无效，即使发生在未执行的OP_IF分支</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.比特币脚本支付有哪些类型</h2>

<h3 id="toc_6">付款到公钥哈希</h3>

<p>（Pay-to-Public-Key-Hash）<br/>
这种交易的脚本类型，在<a href="./15358583883222.html#%E4%BA%A4%E6%98%93%E7%9A%84%E8%84%9A%E6%9C%AC%E5%88%9D%E7%AA%A5">一篇对比特币交易的理解-交易的脚本初窥</a>)有具体的说明</p>

<h3 id="toc_7">多重签名</h3>

<p>多重签名脚本设置了一个条件，其中N个公钥被记录在脚本中，并且至少有M个必须提供签名来解锁资金。也称为&quot;m-n方案&quot;，其中n是密钥的总数，m是验证签名所需的签名数量<br/>
设置M-N多重签名条件的锁定脚本的一般是：</p>

<pre><code class="language-text">M &lt;public key 1&gt; &lt;public key 2&gt; ... &lt;public key N&gt; N OP_CHEACKMULTSIG
</code></pre>

<p>或者说3个存档公钥中的任意2个相一致的私钥签名组合给予解锁，输入和输出组合将形成一个验证的脚本：</p>

<pre><code class="language-text">0 &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public key A&gt; &lt;Public key B&gt; &lt;Public key C&gt; 3 OP_CHECKMULTSIG
</code></pre>

<blockquote>
<p>multsig解锁脚本如果看到一个额外的0开始，其目的是解决一个bug，即保证例子中3个私钥签名（其中2个有效签名，其中一个为0的无效签名）对应3个公钥用于检查多重签名，从而保证脚本不产生bug</p>
</blockquote>

<h3 id="toc_8">付款到脚本P2SH</h3>

<p>（Pay-to-Script-Hash）<br/>
P2SH在2012年被作为一种新型，强大，且能大大简化复杂交易脚本类型而引入的<br/>
上面我讲述了多重签名的应用，虽然满足资金的多方管理，但是同时带来很多的不便，例如必须在客户付款前将该脚本发送给每一个客户，而且每一位客户也必须使用特制能产生交易脚本的比特币钱包的软件，每位顾客还得学会如何利用脚本来完成交易。</p>

<p>另外，脚本可能包含特别长的公钥，最终的交易也比较大给客户的造成费用的负担</p>

<p>最后，一个长的交易脚本记录在UTXO中，这种复杂输出脚本使得实际交易中变的困难重重</p>

<p>P2SH，正是为了解决这一实际的难题而引入的，复杂的锁定脚本被电子指纹（密码学中的哈希）所取代，在P2SH交易中，锁定脚本由哈希运算后的20个字节的散列值取代，被称为赎回脚本，因为它在系统中是赎回时出现而不是以锁定脚本模式出现的</p>

<p>1.不含P2SH的复杂脚本</p>

<table>
<thead>
<tr>
<th>脚本</th>
<th>code</th>
</tr>
</thead>

<tbody>
<tr>
<td>锁定脚本</td>
<td>2 pubkey1 pubkey2 pubkey3 pubkey4 pubkey5 5 OP_CHECKMULSIG</td>
</tr>
<tr>
<td>解锁脚本</td>
<td>sig1 sig2</td>
</tr>
</tbody>
</table>

<p>2.P2SH的复杂脚本</p>

<table>
<thead>
<tr>
<th>脚本</th>
<th>code</th>
</tr>
</thead>

<tbody>
<tr>
<td>赎回脚本</td>
<td>2 pubkey1 pubkey2 pubkey3 pubkey4 pubkey5 5 OP_CHECKMULSIG</td>
</tr>
<tr>
<td>锁定脚本</td>
<td>OP_HASH160 <20-btye hash of 赎回脚本> OP_EQUAL</td>
</tr>
<tr>
<td>解锁脚本</td>
<td>sig1 sig2 赎回脚本</td>
</tr>
</tbody>
</table>

<p>3.对比上面两种类型脚本</p>

<p>可以看出复杂的脚本不会在锁定脚本中显示，而且对于其它的随机节点也方便了验证，同时也减少了字节，同时使得给矿工的交易费用从发送发转移到收款方，复杂的计算及验证的工作也是由发送发转移到收款方</p>

<p>4.多重签名的脚本详解（m-n Multisig）<br/>
 用一个交易作为示例：<a href="http://blockmeta.com/tx/c8bc7cff08249ea5f9970e15be64259b0135b0b6e37f1f9f088a719508cbd8bc">http://blockmeta.com/tx/c8bc7cff08249ea5f9970e15be64259b0135b0b6e37f1f9f088a719508cbd8bc</a><br/>
c8bc7cff08249ea5f9970e15be64259b0135b0b6e37f1f9f088a719508cbd8bc </p>

<ul>
<li>3Ae2TYfyHvwH11pUy6HaK7rBYn9GfGZ3Fk（Input）</li>
<li>17EFZ829NBT2WETLj3wJ5YUfXVaGckuUgs（Input） </li>
<li>1BQpsoxUq7N5Hv57QCnzLBbZSHGtqafaFy（Output） </li>
<li>3Ae2TYfyHvwH11pUy6HaK7rBYn9GfGZ3Fk（Output）<br/></li>
</ul>

<p>第一个输入</p>

<pre><code class="language-text">00 （OP_FALSE，约定为P2SH方式）
48 （第1个签名的字节数)
304502210080075aa29c42f8062f75cf6ab32004944417af974775581719008052c78719710220409fee54c6ddf2ca83e090077e443f95b427a63cc1ad87fca2625951b789d1c2 (第1个签名）
01 （约定所签名的数据为HASH_ALL（tx))
49（第2个签名的字节数)
3046022100b61d8f206d17efd6db32dad106f754f231ee8a16882929b1eb39a58bfd36b39e022100c62cff92dd6fb22b373025fc9b87044cf1b33502acc9de707e5f54d1c8a042a7 （第2个签名）
01 （约定所签名的数据为HASH_ALL（tx))
47 （支付合同脚本的字节数）
52 （OP_2, 表明m-n签名中的m = 2)
21  (第1个公钥的字节数）
0293baf0397588acc1aba056e868fd188dc0eea7554b45370aae862f9d2493a4c1
21  (第2个公钥的字节数）
020ab7517cf22a46b503ee8dcae7f9f109ec4cd19f0ab9d77c89c607554f3d5aa9（第一个公钥）
52（OP_2, 表明m-n签名中的n = 2, 说明这是一个2-2签名)
ae（OP_CHECKSIGVERIFY)
</code></pre>

<p>第二个输入</p>

<pre><code class="language-text">48 （签名的字节数）
304502203fe5f04a013512a4773414b25edc8c7915473dd5cf87bc73d28e1aaffdb4d14f022100e16156d526d1498f2cf5eb02d53e02f7fd5cf1dfdd25e4b032fdc5c59c9fd27b （签名）
01 （约定所签名的数据为HASH_ALL（tx))
21 （公钥的字节数）
0203635e5c184951e14fcfecc83b15960594f4fceec729e09a4a517b0a03a7f4b9 （公钥）
</code></pre>

<p>第一个输出</p>

<pre><code class="language-text">OP_DUP
OP_HASH160
14 (字节数，0x14 = 20L, 网站在显示时省略了这一字节）
7232ca33e0797405a512fa872934cd922c812965 （20字节的哈希值）
OP_EQUALVERIFY
OP_CHECKSIG
</code></pre>

<p>第二个输出</p>

<pre><code class="language-text">OP_HASH160
14 (字节数，0x14 = 20L, 网站在显示时省略了这一字节）
622854939d571b63df97f47e8302b700ab2932b6 （20字节的哈希值）
OP_EQUAL
</code></pre>

<h4 id="toc_9">P2SH地址</h4>

<p>将脚本哈希编译为一个地址，P2SH地址是基于Base58编码的一个含有20个字节的哈希，P2SH地址隐藏了所有的复杂性，因此，运用进行支付的人将不会看到脚本</p>

<h4 id="toc_10">P2SH的优点</h4>

<ol>
<li>交易输出中，复杂的脚本由简短的电子指纹取代，使得交易代码变短</li>
<li>脚本能编译为地址，支付指令发出着和支付者的比特币钱包不需要复杂的工序就可执行</li>
<li>将构建脚本的重担转移至接收方，而非发送发</li>
<li>将长脚本数据存储负担从输出方（存储UTXO，影响内存）转移至输入方（存储在区块链里面）</li>
<li>将长脚本数据存储的重担从当前转移到未来</li>
<li>交易费从发送发转移至接收方，接收方使用该币资金时，必须含有赎回脚本</li>
</ol>

<h4 id="toc_11">赎回脚本和标准确认</h4>

<blockquote>
<p>P2SH锁定脚本包含一个赎回脚本的哈希，该脚本对于赎回脚本本身未提供任何的描述。P2SH交易即便在赎回脚本无效的情况下也会被认为有效，如果处理不当，可能会出现一个事故，即你的比特币可能会锁死在P2SH这个交易中，导致你以后再也不能花费这笔交易了，同时也会导致内存中UTXO变大 </p>
</blockquote>

<p>支付到脚本的类型验证的方式：<br/>
1.验证赎回脚本和锁定脚本是否匹配<br/>
2.通过后在执行赎回的脚本</p>

<blockquote>
<p>以下是执行的脚本顺序<br/>
例如：<br/>
赎回脚本： <2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG><br/>
锁定脚本：OP_HASH160  &lt;赎回脚本 scriptHash&gt; OP_EQUEAL<br/>
解锁脚本：Sig1 Sig2 <2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG><br/>
那么整个脚本执行入栈的依次顺序是：<br/>
赎回脚本入栈，锁定脚本入栈，解锁脚本入栈</p>
</blockquote>

<h3 id="toc_12">如何存储数据到区块链上</h3>

<p>将数据存储到区块链上，同时也叫做数据零知识证明</p>

<h4 id="toc_13">多重签名</h4>

<p>Multi-Signaturnes，可用部分公钥作为数据的存储，又称为外带数据<br/>
例如：一个交易的输出为：</p>

<p><strong>1 Publickey OP_HASH160(外带数据) 2 OP_CHECKMULTSIGN</strong></p>

<p>该交易的输出证明，只有有人证明该公钥对应的私钥拥有者，就说明了外带数据是由私钥拥有者所有</p>

<h4 id="toc_14">数据记录输出（OP_RETURN操作符）</h4>

<p>2013年，比特币协议引进了一项新的功能，即创建一种名为OP_RETURN的交易，可以嵌入40个字节小段数据（目前已经是80字节）</p>

<p>这个功能最初是把情景信息加入比特币交易中，比如配送信息等，后来发展为更具有创造性的用法，即创造最小量的交易（0.00000001BTC的交易费），并且可以嵌入任何你想放进去的信息</p>

<p>例如：交易号：793430203367a558101239a5719043230205367a558100039a57190</p>

<p><strong>OP_RETURN 43430205367a558100039a57190</strong></p>

<blockquote>
<p>利用这个功能产生一个有趣的应用就是，存在性证明(Proof of Existence) <br/>
不过需要注意的是，OP_TRUEN交易输出是不进入UTXO集合中，所以是无法再次交易的<br/>
一个标准的交易（通过isStandard()函数检验的）只能有一个RETURN输出，不过单个OP_RETURN可以和任意类型的输出交易进行组合</p>
</blockquote>

<h2 id="toc_15">3.时间锁</h2>

<p>时间锁（timelocks）是允许一段时间后才允许支出交易；<br/>
比特币一开始有一个交易级的时间锁定功能（nlocktime）<br/>
2015年低和2016年中推出了两个新的时间锁定功能，提供UTXO级别的时间锁定功能，分别是<strong>CHECKLOCKTIMEVERIFY</strong>和<strong>CHECKEQUENCEVERIFY</strong></p>

<h3 id="toc_16">交易锁定时间</h3>

<p>nlocktime，大多数交易中将其设置为零，表示即时的传播和执行<br/>
如果nlocktime不为零，低于5亿，则将其解释为块的高度，这意味着小于该区块高度交易无效<br/>
如果超过了5亿，它被解释为Unix时间戳，并且小于当前时间戳交易无效</p>

<p>通常nlocktime和<strong>sequence</strong>同时使用</p>

<blockquote>
<p>交易的序列，该值的范围是0-232 -1，该值往往是和下面的locktime配合使用的，当sequence=232 -1，则就忽略locktime的功能；</p>

<p>当locktime是未来的时间，且sequence&lt;232 -1的时候，那么到了loacktime的时候，以sequence最大的准，其它的交易将会从交易池中移除</p>
</blockquote>

<p>关于交易时间限制的问题说明<br/>
例如小宋给小李签署一笔交易，将交易的时间nlocktime设定为3个月</p>

<blockquote>
<ul>
<li>在3个月内，小李不能使用该笔交易</li>
<li>小李可以在3个月之后接受交易</li>
</ul>
</blockquote>

<p>然而</p>

<blockquote>
<ul>
<li>小宋可以再创建一个交易，双重花费相同的输入，而不需要锁定时间，因此小宋可以在3个月过去之前花费相同的UTXO</li>
<li>小李不能保证小宋不会这样做</li>
</ul>
</blockquote>

<p>所以唯一保证的是小李3个月之内无法兑换此交易，也就是说不能保证小李一定可以得到资金，为了实现这样的保证，时间限制必须放在UTXO本身上，并称为锁定脚本的一部分，而不仅仅是交易。</p>

<h3 id="toc_17">检查锁定时间验证</h3>

<p>check lock time verify (CLTV)<br/>
2015年12月，引入了一种新的形式的时间锁进行比特币的分叉升级，CLTV允许再应用时间锁的方式上具有更大的灵活性，简单的说通过在输出的赎回脚本中添加CLTV操作码来限制输出，从而只能在指定的时间后使用。</p>

<blockquote>
<p>当nlocktime是交易级时间锁定时，CLTV则是基于输出的时间锁</p>
</blockquote>

<pre><code class="language-text">OP_DUP HASH160 &lt;public key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<pre><code class="language-text">&lt;now + 3 months&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP 
OP_DUP HASH160 &lt;public key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<p>CLTV不会取代nlocktime的，而是限制特定的UTXO;<br/>
CLTV和nlocktime同时使用的话，CLTV的时间小于等于nLocktime的时间，CLTV和nlocktime（块的高度和Unix纪元时间）保持相同的格式</p>

<p>CLTV和nlocktime的场景组合使用，从使用的角度来说交易锁的级别是大于输出锁的</p>

<ul>
<li><p>场景描述：A给B转账，要求立即到账，但是B需要3个月后方花费这笔交易（解决双花问题）</p>
<pre><code class="language-text">交易锁nlocktime = 0，CLTV = Now+3Month
</code></pre></li>
<li><p>场景描述：A给B转账，要求3个月后到账</p>
<pre><code class="language-text"> 方式一：交易锁nlocktime = Now+3Month，CLTV = Now+3Month（CLTV可加，可不加）
 方式二：交易锁nlocktime = Now+3Month，nsenquece &lt; 2^32 -1（容易出现双花）
</code></pre></li>
<li><p>场景描述：A给B转账，要求3个月后到账，之后B要求立即到账</p>
<pre><code class="language-text">1.创建第一个交易，
交易锁nlocktime = Now+3Month，nsenquece &lt; 2^32 -1         <br/>
2.再创建一个相同的交易，但是设置nsenquece为最大<br/>
交易锁nlocktime = Now+3Month，nsenquece = 2^32 -1，CLTV=0（如有输出的锁就要忽略）    <br/>
那么交易锁碰到nsenquece最大的时候，就表示立即执行交易，忽略nlocktime
</code></pre></li>
</ul>

<h3 id="toc_18">相对时间锁</h3>

<p>nlocktime和CLTV都是绝对锁，他们是指定的绝对时间点，接下来讲解的是相对锁定</p>

<p>2016年5月份相对时间锁的软分叉升级的共识规则<br/>
相对锁的主要应用场景，是允许两个或多个相互依赖的交易链在一次，同时对依赖与从先前交易的确认所经过的时间的一个交易施加时间约束。<br/>
也就是说，在UTXO被记录在块之前，时钟不开始计数，这个功能在双向状态通道和闪电网络中特币有用，后面我们会讲到</p>

<p>相对时间锁，同时也具有交易级别和脚本级别的操作码<br/>
交易级相对时间锁对应每个交易输入中设置的交易字段nSequence的值共识规则实现<br/>
脚本级相对时间锁定使用OP_CHECKSEQUENCVERIFY(CSV)操作码来实现的</p>

<h4 id="toc_19">nSequence相对时间锁</h4>

<p>nSequence设计的初心说想让交易能在内存中修改，可惜后面从未使用过，使用nSequence这个字段，如果输入的交易序列小于2<sup>32</sup> (0xffffffff)，就表示尚未“确认”的交易</p>

<p>这样交易将在内存池中保存，直到被另一交易消耗相同输入并具有较大的nSequence值代替，一旦出现了nSequence=2<sup>32</sup> -1，那么将被视为“最终确定”，将会立即进入打包到矿池</p>

<p>一笔输入的交易，当输入的脚本中nSequence &lt; 2<sup>31</sup> 时候，就相当于时间锁定的输入交易，这中交易只有到了相对锁定时间后才生效</p>

<blockquote>
<p>定义如下：<br/>
nSequence &lt; 2<sup>31</sup> 表示相对时间锁<br/>
nSequence &gt;= 2<sup>31</sup> &amp;&amp; nSequence &lt;= 2<sup>32</sup> -1 表示普通的锁，没有相对时间</p>
</blockquote>

<h4 id="toc_20">带CSV的相对时间锁</h4>

<h3 id="toc_21">中位时间过去Median-Time-Past</h3>

<h3 id="toc_22">针对费用阻击（Fee Sniping）的时间锁定</h3>

<h2 id="toc_23">4.具有流量控制的脚本（条件字句）</h2>

<p>比特币的条件操作码允许我们构建一个具有两种解锁方式的赎回脚本，这取决于苹果逻辑条件的TRUE/FALSE，例如如果x为true，则赎回脚本为A,else赎回脚本为B,此外表达的条件可以无限期的“嵌套”</p>

<pre><code class="language-text">大多数编程语言的流控制
if（条件）:
    code to run when 条件 is true
else:
    code to run when 条件 is false
code to run in either case
 
 
BitCoin脚本流控制
条件
IF
    code to run when 条件 is true
ELSE
    code to run when 条件 is false
ENDIF
code to run in either case
</code></pre>

<h3 id="toc_24">VERIFY操作码的条件字句</h3>

<p>在脚本中一个条件是任何以VERIFY结尾的操作码，表示如果评估的条件不为TRUE，脚本的执行将立即终止，并且该交易被视为无效。<br/>
与提供代替执行路径的IF字句不同，VERIFY后缀充当保护字句，只有在满足前提的条件下才会继续；</p>

<p>例如，脚本需要用户小a的签名和产生的特定哈希前的数据DATA</p>

<p>方式一：</p>

<pre><code class="language-text">赎回脚本：OP_HASH160 &lt; DATA hash &gt; OP_EQUALVERIFY &lt; a&#39; pubkey &gt; OP_CHECKSIG

锁定脚本： OP_HASH160 &lt;20-btye hash of 赎回脚本&gt; OP_EQUAL

解锁脚本：&lt; a&#39; sig &gt; &lt; 赎回脚本 &gt;
</code></pre>

<p>方式二：</p>

<pre><code class="language-text">锁定的脚本如下：
OP_HASH160 &lt;预期的 HASH&gt; OP_EQUAL
IF
    &lt;a&#39;s pubkey&gt; OP_CHECKSIG
ENDIF


解锁的脚本如下：
&lt;a&#39;s Sig&gt;  &lt;hash DATA&gt;
</code></pre>

<p>方式三：</p>

<pre><code class="language-text">赎回脚本：
OP_HASH160 &lt;预期的 HASH&gt; OP_EQUAL
IF
    &lt;a&#39;s pubkey&gt; OP_CHECKSIG
ENDIF


锁定脚本：
OP_HASH160 &lt;赎回脚本 HASH&gt; OP_EQUAL


解锁脚本：
&lt;a&#39;s Sig&gt;  OP_HASH160 &lt;预期的 HASH&gt; OP_EQUAL IF &lt;a&#39;s pubkey&gt; OP_CHECKSIG ENDIF
</code></pre>

<h3 id="toc_25">在脚本中使用流控制</h3>

<p>在脚本流量控制一个非常常见的用途是构建一个提供多个执行路径的赎回脚本，每个脚本都有一种不同的赎回UTXO的方式</p>

<p>例如：1-of-2多重的签名</p>

<pre><code class="language-text">赎回的脚本：
IF
    &lt;A&#39;s Pubkey&gt; OP_CHECKSIG
ELSE
    &lt;B&#39;s Pubkey&gt; OP_CHECKSIG
ENDIF

解锁的脚本：
&lt; A&#39;s Sig &gt; 1
&lt; B&#39;s Sig &gt; 0

</code></pre>

<p>再例如一个复杂的多重嵌套脚本case</p>

<pre><code class="language-text">赎回脚本：
IF
    script A
ELSE
    IF
        script B
    ELSE
        script C
    ENDIF
ENDIF

解锁的脚本：
scriptB解锁的路径，1 0
scriptC解锁的路径，0 0
scriptA解锁的路径，1
</code></pre>

<blockquote>
<p>注意解锁脚本的路径，由于解锁的脚本是先入栈的，所有交互的路径感觉是反着呢</p>
</blockquote>

<h2 id="toc_26">5.复杂的脚本的运用</h2>

<h3 id="toc_27">一个case</h3>

<p>例如，某公司希望创建灵活的规则建立公司的资本账户，多重签名计划的参与者Song，以及他的两个合伙人Zhang和Li，以及公司的律师Lawyer，创建不同级别的授权，具体取决于时间锁定；<br/>
具体的业务如下：<br/>
三个合伙人根据多数规则作出决定，因此三种中两个必须同意，然而如果他们的钥匙有问题，他们希望律师能够用三个合伙人获取签名之一收回资金，最后，如果所有的合伙人一段时间都不可用或无行为能力，他们希望律师能够直接管理该账户</p>

<pre><code class="language-text">赎回脚本：

IF
    IF
        2
    ELSE
        &lt;30 days&gt; OP_CHECKQUENCEVERIFY DROP
        &lt;Lawyer pubkey&gt; OP_CHECKSIGVERIFY
        1
    ENDIF
        &lt;Song&#39;s pubkey&gt; &lt;Zhang&#39;s pubkey&gt; &lt;Li&#39;s pubkey&gt; 3 OP_CHECKMULTSIG
ELSE
    &lt;90 days&gt; OP_CHECKQUENCEVERIFY DROP   //注意这是一个相对的时间脚本锁
    &lt;Lawyer pubkey&gt; OP_CHECKSIG
ENDIF


解锁脚本：

路径1: &lt;Lawyer Sig&gt; 0 (90天之后，律师放可以单独的花费该笔资金)
路径2: 0 &lt;Song&#39;s Sig&gt; &lt;Zhang&#39;s Sig&gt; 1 1 (三个合伙人中有两个签名就可以花费该笔资金)
路径3: 0 &lt;Song&#39;s Sig&gt; &lt;Lawyer Sig&gt; 0 1 (超过三十天，律师签名加上三个合伙人中任意一个人就可以花费该笔资金)
 
</code></pre>

<p>针对上面的Case，一些扩展的思考及实现</p>

<ul>
<li>为什么要用nSequence相对时间锁？而不用脚本CHECKLOCKTIMEVERIFY(CLTV)普通锁？</li>
<li>CHECKSIG操作码后缀为什么有些有VERIFY，有些没有？</li>
<li>如果律师失去钥匙，资金是否流失？</li>
<li>如果91天过去了，律师是否可以直接花费该笔资金？</li>
<li>合作伙伴如何每隔29天或89天“重置”一次，以防止律师获取资金？</li>
<li>是否可以让律师有备份的钥匙？</li>
</ul>

<h3 id="toc_28">case问题解答</h3>

<ol>
<li><p>为什么要用nSequence相对时间锁？而不用脚本CHECKLOCKTIMEVERIFY(CLTV)普通锁？</p>
<blockquote>
<p>相对时间锁，是说明了该交易的输出已经进入了UTXO集合了</p>
</blockquote></li>
<li><p>CHECKSIG操作码后缀为什么有些有VERIFY，有些没有？</p>
<blockquote>
<p>所有操作码包含VERIFY，就是当执行验证失败则会中断下面等流程，标记交易失败</p>
</blockquote></li>
<li><p>如果律师失去钥匙，资金是否流失？</p>
<blockquote>
<p>仅仅律师丢了私钥是不会造成资金丢失的，但是如果3个合伙人中丢了两把钥匙，那么这笔资金就永远无法花费了，也就是等同了资金的流失；</p>
</blockquote>
<p>增加一定时间后，任何一个合伙人私钥签名即可花费该笔交易，具体实现如下：</p>
<pre><code class="language-text">赎回脚本：
IF<br/>
    IF<br/>
        2<br/>
    ELSE<br/>
        IF<br/>
            &lt;30 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
            &lt;Lawyer pubkey&gt; OP_CHECKSIGVERIFY<br/>
        ELSE<br/>
            &lt;60 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
        ENDIF<br/>
            1<br/>
    ENDIF<br/>
        &lt;Song&#39;s pubkey&gt; &lt;Zhang&#39;s pubkey&gt; &lt;Li&#39;s pubkey&gt; 3 OP_CHECKMULTSIG<br/>
ELSE<br/>
    &lt;90 days&gt; OP_CHECKQUENCEVERIFY DROP   //注意这是一个相对的时间脚本锁<br/>
    &lt;Lawyer pubkey&gt; OP_CHECKSIG<br/>
ENDIF   <br/>
解锁脚本：<br/>
路径1：0 &lt; Song&#39;s Sig &gt; &lt; Lawyer&#39;s Sig &gt;  1 0 1<br/>
如果超过30天了，那么律师私钥签名+三个合伙人中其中任何一个私钥签名，即可花费该笔交易<br/>
路径2：0 &lt; Song&#39;s Sig &gt; 0 0 1<br/>
如果超过60天了，那么三个合伙人中其中任何一个私钥签名，即可花费该笔交易
</code></pre></li>
<li><p>如果91天过去了，律师是否可以直接花费该笔资金？</p>
<blockquote>
<p>是的</p>
</blockquote></li>
<li><p>合作伙伴如何每隔29天或89天“重置”一次，以防止律师获取资金？</p>
<blockquote>
<p>目前还没有太好解决思路？</p>
</blockquote></li>
<li><p>是否可以让律师有备份的钥匙？</p>
<blockquote>
<p>可以让律师有两把钥匙，作为其中一个备份</p>
</blockquote>
<pre><code class="language-text">赎回脚本：
IF<br/>
    IF<br/>
        2<br/>
    ELSE<br/>
        IF<br/>
            &lt;30 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
            1 &lt;Lawyer pubkey&gt; &lt;Lawyer2 pubkey&gt; 2 OP_CHECKMULTSIGVERIFY<br/>
        ELSE<br/>
            &lt;60 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
        ENDIF<br/>
            1<br/>
    ENDIF<br/>
        &lt;Song&#39;s pubkey&gt; &lt;Zhang&#39;s pubkey&gt; &lt;Li&#39;s pubkey&gt; 3 OP_CHECKMULTSIG<br/>
ELSE<br/>
    &lt;90 days&gt; OP_CHECKQUENCEVERIFY DROP   //注意这是一个相对的时间脚本锁<br/>
    1 &lt;Lawyer pubkey&gt; &lt;Lawyer2 pubkey&gt; 2 OP_CHECKMULTSIG<br/>
ENDIF   <br/>
解锁脚本：<br/>
路径1：0 &lt; Song&#39;s Sig &gt; 0 &lt; Lawyer&#39;s Sig &gt;  1 0 1<br/>
如果超过30天了，那么律师私钥签名+三个合伙人中其中任何一个私钥签名，即可花费该笔交易<br/>
路径2：0 &lt; Lawyer&#39;s Sig &gt; 0<br/>
如果超过了90天后，律师可以用其中两把私钥中任意一个都可以完成私钥签名，即可花费该笔交易<br/>
```
</code></pre></li>
</ol>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15358584946404.html" 
          title="Previous Post: 一篇对比特币挖矿的理解">&laquo; 一篇对比特币挖矿的理解</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15358583883222.html" 
          title="Next Post: 一篇对比特币交易的理解">一篇对比特币交易的理解 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          
            <div id="disqus_thread"></div>
          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>我对区块链的理解</h1>
                <div class="site-des">对区块链的思考</div>
                <div class="social">







<a target="_blank" class="weibo" href="https://weibo.com" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:spzhongwin@google.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="poofAlgorithm.html"><strong>共识算法</strong></a>
        
            <a href="about.html"><strong>关于</strong></a>
        
            <a href="index.html"><strong>指引</strong></a>
        
            <a href="bit.html"><strong>比特币</strong></a>
        
            <a href="ethereum.html"><strong>以太坊</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15365050797831.html">一篇对数字签名的理解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15360563845824.html">关于</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358586085164.html">一篇对比特币的应用案例分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358585289735.html">一篇对比特币网络的理解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358584946404.html">一篇对比特币挖矿的理解</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2018
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>


<script type="text/javascript">
    var disqus_shortname = 'coderforart'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'coderforart'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
