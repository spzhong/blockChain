<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  比特币 - 我对区块链的理解
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="我对区块链的理解" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>

<link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermaid.css">
<!--        <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermadidstyle.css">-->
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/jquery.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/rawdeflate.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/encode64.js"></script>
            <script src="asset/sample-custom-html-charts/echarts.common.min.js"></script>
            <script src="asset/sample-custom-html-charts/mermaid.min.js"></script>
            <script type="text/javascript">
                $(function(){
                  var mwebii=0;
                  var mwebChartEleId = 'mweb-chart-ele-';
                  $('pre>code').each(function(){
                                     mwebii++;
                                     var eleiid = mwebChartEleId+mwebii;
                                     if($(this).hasClass('language-mermaid')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div id="'+eleiid+'"></div>').addClass('mermaid').html($(this).text()).insertAfter(ele);
                                     }else if($(this).hasClass('language-plantuml')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     var str = unescape(encodeURIComponent($(this).text()));
                                     var imgURL = "http://www.plantuml.com/plantuml/svg/"+encode64(deflate(str,9));
                                     var newEle = $('<div id="'+eleiid+'"><img src="'+imgURL+'" /></div>').insertAfter(ele);
                                     }else if($(this).hasClass('language-js-echarts')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div style="width: 100%;height:400px;" id="'+eleiid+'"></div>').insertAfter(ele);
                                     var myChart = echarts.init(document.getElementById(eleiid));
                                     try  {
                                     eval($(this).text());
                                     myChart.setOption(option);
                                     }catch(exception) {}
                                     }
                                     });
                  
                  mermaid.init({noteMargin: 10}, ".mermaid");
                  });
                </script>



  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">首页</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        <li id=""><a target="_self" href="about.html">关于</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 我对区块链的理解</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">首页</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        
        <li><a target="_self" href="about.html">关于</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="poofAlgorithm.html">共识算法</a></li>
        
            <li><a href="about.html">关于</a></li>
        
            <li><a href="index.html">指引</a></li>
        
            <li><a href="bit.html">比特币</a></li>
        
            <li><a href="ethereum.html">以太坊</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15365050797831.html">
                
                  <h1>一篇对数字签名的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>比特币是基于密码学的，密码学这门科学不仅包含被称之为“秘密写作的”加密学，也可以用来证明秘密的知识，而不会泄漏秘密（数字签名），或证明数据的真实性（数字指纹），接下来介绍一下比特币中来控制资金的所有权的密码学，包括了密钥，地址和钱包。</p>

<ul>
<li>
<a href="#toc_0">数字签名</a>
<ul>
<li>
<a href="#toc_1">简介</a>
</li>
<li>
<a href="#toc_2">公钥加密和加密货币</a>
</li>
<li>
<a href="#toc_3">私钥和公钥</a>
</li>
<li>
<a href="#toc_4">私钥</a>
</li>
<li>
<a href="#toc_5">公钥</a>
</li>
<li>
<a href="#toc_6">椭圆曲线密码学(Elliptic Curve Cryptography)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">比特币地址</a>
<ul>
<li>
<a href="#toc_8">Base58和Base58Check编码</a>
</li>
<li>
<a href="#toc_9">密钥格式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">用Python实现密钥和比特币地址</a>
</li>
<li>
<a href="#toc_11">高级密钥和地址</a>
</li>
</ul>


<h2 id="toc_0">数字签名</h2>

<h3 id="toc_1">简介</h3>

<p>比特币的所有权是通过数字密钥，比特币地址和数字签名来确定的，数字密钥实际上不是存储在网络中的，而是由用户独立生成的，存储在钱包文件中或是数据库中；密钥实现了比特币的许多趣味性，包括去中心化信任和控制，所有权认证和基于密码学证明的安全模型</p>

<p>大多数比特币交易都需要一个有效的签名才会被存储在区块链中，只有有效的密钥才能产生有效的数字签名，因此拥有-密钥就拥有了对该账户的比特币的控制权，那么交易中的见证数据证明了所用资金的真正归谁所有</p>

<p>密钥是成对出现的，有一个私钥和公钥所组成</p>

<p>首先我们先介绍密码学并解释比特币中使用的数学知识，然后了解密钥如何被产生的，存储和管理的，代表私钥和公钥，地址和脚本地址的各种编码格式，最后，说一下密钥和地址的高级用途：比特币靓号，多重签名以及脚本地址和纸钱包</p>

<h3 id="toc_2">公钥加密和加密货币</h3>

<p>公钥加密发明于20世纪70年代，它是计算机和信息安全的数学基础。<br/>
例如，素数幂和椭圆曲线乘法，这些函数都是不可逆的，很容易向一个方向计算，但是不可以向反方向倒推。比特币正使用椭圆曲线乘法作为公钥加密的基础</p>

<p>支付比特币时，比特币的当前所有者需要交易中提交其公钥和签名（每次交易的签名都不同，但均是同一个私钥生成的），所有比特币网络中的所有人都可通过提交的公钥和签名进行验证，并确认该交易是否有效，即支付者拥有该交易的比特币的所有权</p>

<blockquote>
<p>大多数比特币钱包工具为了方便将私钥和公钥以密钥对的形式存储在一起，然而公钥可以由私钥计算的到，所以只存储私钥即可</p>
</blockquote>

<h3 id="toc_3">私钥和公钥</h3>

<p>一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥，私钥(k)是一个数字，通常是随机选的，有了私钥通过椭圆曲线乘法这个单向加密的函数产生一个公钥，然后使用一个单向加密哈希函数生成比特币地址</p>

<p>为什么要使用非对称加密（公钥/私钥）？<br/>
非对称密码学适用性使得任何人都可以验证每笔交易的每个签名，同时确保只有私钥的所有者可以产生有效的签名</p>

<h3 id="toc_4">私钥</h3>

<p>私钥就是一个随机选出的数字而已。私钥必须始终保持机密，因为一旦泄漏给第三方，那么就相当于将该私钥下的控制的比特币所有权拱手于人；私钥还必须要备份，一旦丢失同理也是弃掉了将该私钥下的控制的比特币所有权</p>

<blockquote>
<p>私钥生成，随机256位的二进制数字（64位的16进制）</p>

<blockquote>
<p>2<sup>256</sup> 是一个非常大数字，用十进制表示的话大约10<sup>77</sup> ，而可见宇宙被估计只含有10<sup>80</sup> 个原子</p>
</blockquote>
</blockquote>

<h3 id="toc_5">公钥</h3>

<p>通过椭圆曲线乘法可以从私钥计算得到公钥，这个过程不可逆转：K = k*G (k是私钥，G被称为生成点点常数点，而K是所得的公钥)<br/>
通过私钥，可以计算得到公钥，但是由于过程不可逆，无法通过公钥得到私钥</p>

<h3 id="toc_6">椭圆曲线密码学(Elliptic Curve Cryptography)</h3>

<p>椭圆曲线加密法是一种基于离散对数问题的非对称加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。</p>

<blockquote>
<p>y<sup>2</sup> = x<sup>3</sup> + ax + b<br/>
<img src="media/15365050797831/20170801154403156.gif" alt="20170801154403156"/><br/>
备注：动态效果图参看<a href="https://blog.csdn.net/dianqu6970/article/details/76534222">椭圆曲线加密学习</a></p>
</blockquote>

<p><img src="media/15365050797831/121401537009791_.pic_hd.jpg" alt="121401537009791_.pic_hd"/></p>

<h2 id="toc_7">比特币地址</h2>

<p>以公钥K为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160哈希值，得到一个长度160位（20字节）的数字：</p>

<blockquote>
<p>A = RIPEMD160(SHA256(K))<br/>
  address = Base58 Encode(A)</p>
</blockquote>

<h3 id="toc_8">Base58和Base58Check编码</h3>

<p>为了更简洁方便表示长串的数字，使用更少的符号，许多计算机会使用一种以数字和字母组成的大于十进制的表示法；<br/>
Base64使用了26个大小写字母，10个数字及两个符号（+ /）<br/>
Base58是一种基于文本的二进制编码格式，这种编码格式不仅实现了数据压缩，保持了易读性，Base58不包含数字0，字母o，大小写i，以及+ / ，比Base64少了6个字符</p>

<p><img src="media/15365050797831/1411537524443_.pic_hd.png" alt="1411537524443_.pic_hd"/></p>

<h3 id="toc_9">密钥格式</h3>

<h2 id="toc_10">用Python实现密钥和比特币地址</h2>

<h2 id="toc_11">高级密钥和地址</h2>

<p><a href="https://blog.csdn.net/taifei/article/details/74382718">https://blog.csdn.net/taifei/article/details/74382718</a><br/>
<a href="https://blog.csdn.net/taifei/article/details/73880736">https://blog.csdn.net/taifei/article/details/73880736</a><br/>
<a href="https://blog.csdn.net/ztemt_sw2/article/details/81101717">https://blog.csdn.net/ztemt_sw2/article/details/81101717</a><br/>
<a href="https://github.com/cyhhao/eth-canvas">https://github.com/cyhhao/eth-canvas</a><br/>
<a href="https://blog.csdn.net/j3t9z7h/article/details/80970818">https://blog.csdn.net/j3t9z7h/article/details/80970818</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15365050797831.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358586085164.html">
                
                  <h1>一篇对比特币的应用案例分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358586085164.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358585289735.html">
                
                  <h1>一篇对比特币网络的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358585289735.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358584946404.html">
                
                  <h1>一篇对比特币挖矿的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358584946404.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358584238347.html">
                
                  <h1>一篇对比特币脚本的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在比特币交易的理解中，我们简单的介绍了脚本及脚本语言是如何运行的，那么这篇文章我具体的讲讲脚本的类型用法，及扩展</p>

<ul>
<li>
<a href="#toc_0">1.比特币脚本的特点及基本语法</a>
<ul>
<li>
<a href="#toc_1">脚本的本质</a>
</li>
<li>
<a href="#toc_2">脚本的常见关键字字段</a>
</li>
<li>
<a href="#toc_3">脚本的流控制关键字字段</a>
</li>
<li>
<a href="#toc_4">其它重要的字段说明</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">2.比特币脚本支付有哪些类型</a>
<ul>
<li>
<a href="#toc_6">付款到公钥哈希</a>
</li>
<li>
<a href="#toc_7">多重签名</a>
</li>
<li>
<a href="#toc_8">付款到脚本P2SH</a>
<ul>
<li>
<a href="#toc_9">P2SH地址</a>
</li>
<li>
<a href="#toc_10">P2SH的优点</a>
</li>
<li>
<a href="#toc_11">赎回脚本和标准确认</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">如何存储数据到区块链上</a>
<ul>
<li>
<a href="#toc_13">多重签名</a>
</li>
<li>
<a href="#toc_14">数据记录输出（OP_RETURN操作符）</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_15">3.时间锁</a>
<ul>
<li>
<a href="#toc_16">交易锁定时间</a>
</li>
<li>
<a href="#toc_17">检查锁定时间验证</a>
</li>
<li>
<a href="#toc_18">相对时间锁</a>
<ul>
<li>
<a href="#toc_19">nSequence相对时间锁</a>
</li>
<li>
<a href="#toc_20">带CSV的相对时间锁</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">中位时间过去Median-Time-Past</a>
</li>
<li>
<a href="#toc_22">针对费用狙击（Fee Sniping）的时间锁定</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">4.具有流量控制的脚本（条件字句）</a>
<ul>
<li>
<a href="#toc_24">VERIFY操作码的条件字句</a>
</li>
<li>
<a href="#toc_25">在脚本中使用流控制</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">5.复杂的脚本的运用</a>
<ul>
<li>
<a href="#toc_27">一个case</a>
</li>
<li>
<a href="#toc_28">case问题解答</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.比特币脚本的特点及基本语法</h2>

<p>比特币在交易中使用的脚本系统，于FORTH（一种编译语言）一样，脚本是简单的，基于堆栈的，并且是从左向右处理的，特意设计成非图灵完整的形式，没有LOOP（循环）语句</p>

<h3 id="toc_1">脚本的本质</h3>

<p>实际上脚本本质上是众多指令的列表，交易上的脚本本质是也是输入和输出的入栈的操作指令，使得操作指令False表示0，True表示非0</p>

<h3 id="toc_2">脚本的常见关键字字段</h3>

<table>
<thead>
<tr>
<th>关键字</th>
<th>操作码</th>
<th>十六进制</th>
<th>输入</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>OP_0</td>
<td>0</td>
<td>0x00</td>
<td>无</td>
<td>空</td>
<td>一个字节空串被推到栈中（并非no-op操作，这里有一个元素被压入堆栈中）</td>
</tr>
<tr>
<td>N/A</td>
<td>1-75</td>
<td>0x01-0x4b</td>
<td>特殊</td>
<td>数据</td>
<td>下一个操作码字节被压入堆栈的数据</td>
</tr>
<tr>
<td>OP_PUSHDATA1</td>
<td>76</td>
<td>0x4c</td>
<td>特殊</td>
<td>数据</td>
<td>下一个字节被压入堆栈的数据的长度</td>
</tr>
<tr>
<td>OP_PUSHDATA2</td>
<td>77</td>
<td>0x4d</td>
<td>特殊</td>
<td>数据</td>
<td>下两个字节被压入堆栈的数据的长度</td>
</tr>
<tr>
<td>OP_PUSHDATA4</td>
<td>78</td>
<td>0x4e</td>
<td>特殊</td>
<td>数据</td>
<td>下四个字节被压入堆栈的数据的长度</td>
</tr>
<tr>
<td>OP_1NEGATE</td>
<td>79</td>
<td>0x4f</td>
<td>无</td>
<td>-1</td>
<td>数字-1被压入堆栈</td>
</tr>
<tr>
<td>OP_1</td>
<td>81</td>
<td>0x51</td>
<td>无</td>
<td>1</td>
<td>数字1被压入堆栈</td>
</tr>
<tr>
<td>OP_2-OP_16</td>
<td>82-96</td>
<td>0x52-0x60</td>
<td>无</td>
<td>2-16</td>
<td>关键名对应的数字被压入栈</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">脚本的流控制关键字字段</h3>

<table>
<thead>
<tr>
<th>关键字</th>
<th>操作码</th>
<th>十六进制</th>
<th>输入 / 输出</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>OP_NOP</td>
<td>97</td>
<td>0x61</td>
<td>无</td>
<td>无任何操作</td>
</tr>
<tr>
<td>OP_IF</td>
<td>99</td>
<td>0x63</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>如果栈顶元素值不为0，则语句将被执行，栈顶元素将被删除</td>
</tr>
<tr>
<td>OP_NOTIF</td>
<td>100</td>
<td>0x64</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>如果栈顶元素值为0，则语句将被执行，栈顶元素将被删除</td>
</tr>
<tr>
<td>OP_ELSE</td>
<td>103</td>
<td>0x67</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>如果前述的OP_IF或OP_NOTIF或OP_ELSE未被执行，那么这些语句就会执行，如果执行了，则表示这些语句不会被执行</td>
</tr>
<tr>
<td>OP_ENDIF</td>
<td>104</td>
<td>0x68</td>
<td><expression>if[statements][else[statements]] endif</td>
<td>结束if/else语言块</td>
</tr>
</tbody>
</table>

<h3 id="toc_4">其它重要的字段说明</h3>

<p>脚本的字段关键字有好些，有些操作码已被禁入，我们主要了解一些关键的及常用的字段就可以了。</p>

<table>
<thead>
<tr>
<th>关键字</th>
<th>操作码</th>
<th>十六进制</th>
<th>输入</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>OP_VERIFY</td>
<td>105</td>
<td>0x69</td>
<td>TRUE/FALSE</td>
<td>无/FALSE</td>
<td>如果栈顶原色值非真，则标记交易无效，TRUE会被删除，FALSE不会删除</td>
</tr>
<tr>
<td>OP_RETUEN</td>
<td>106</td>
<td>0x6a</td>
<td>无</td>
<td>无</td>
<td>标记交易无效</td>
</tr>
<tr>
<td>OP_IFDUP</td>
<td>115</td>
<td>0x73</td>
<td>--</td>
<td>--</td>
<td>如果栈顶元素不为0，则复制该元素值</td>
</tr>
<tr>
<td>OP_DROP</td>
<td>117</td>
<td>0x75</td>
<td>--</td>
<td>--</td>
<td>删除栈顶元素</td>
</tr>
<tr>
<td>OP_DUP</td>
<td>118</td>
<td>0x75</td>
<td>--</td>
<td>--</td>
<td>复制栈顶元素</td>
</tr>
<tr>
<td>OP_SWAP</td>
<td>124</td>
<td>0x7c</td>
<td>--</td>
<td>--</td>
<td>栈顶的两个元素交换</td>
</tr>
<tr>
<td>OP_2DROP</td>
<td>109</td>
<td>0x6d</td>
<td>--</td>
<td>--</td>
<td>删除栈顶的两个元素</td>
</tr>
<tr>
<td>OP_2DUP</td>
<td>110</td>
<td>0x6e</td>
<td>--</td>
<td>--</td>
<td>复制栈顶的两个元素</td>
</tr>
<tr>
<td>OP_EQUAL</td>
<td>135</td>
<td>0x87</td>
<td>x1 x2</td>
<td>true/false</td>
<td>如果输入的两个数相等，则返回1，否则返回0</td>
</tr>
<tr>
<td>OP_EQUALVERIFY</td>
<td>136</td>
<td>0x88</td>
<td>x1 x2</td>
<td>true/false</td>
<td>与OP_EQUAL一样，之后运行OP_VERIFY</td>
</tr>
<tr>
<td>OP_RIPEMD160</td>
<td>166</td>
<td>0xa6</td>
<td>in</td>
<td>hash</td>
<td>输入用RIPEMD-160算法散列</td>
</tr>
<tr>
<td>OP_SH256</td>
<td>168</td>
<td>0xa8</td>
<td>in</td>
<td>hash</td>
<td>输入用HAS-256算法散列</td>
</tr>
<tr>
<td>OP_HASH160</td>
<td>169</td>
<td>0xa9</td>
<td>in</td>
<td>hash</td>
<td>输入两次散列哈希，先用SHA-256,再用RIPEMD-160</td>
</tr>
<tr>
<td>OP_HASH256</td>
<td>168</td>
<td>0xa8</td>
<td>in</td>
<td>hash</td>
<td>输入两次SHA-256</td>
</tr>
<tr>
<td>OP_CHECKSIG</td>
<td>172</td>
<td>0xac</td>
<td>sig pubkey</td>
<td>true/false</td>
<td>全部交易的输出，输入和脚本都被散列，使用的签名必须是该Hash值和公钥的有效签名，返回1或0</td>
</tr>
<tr>
<td>OP_CHECKSIGVERIFY</td>
<td>173</td>
<td>0xad</td>
<td>sig pubkey</td>
<td>true/false</td>
<td>与OP_CHECKSIG一样，但之后执行OP_VERIFY</td>
</tr>
<tr>
<td>OP_CHECKMULTISIG</td>
<td>174</td>
<td>0xae</td>
<td>x sig1 sig2 ... number of signatures pub1 pub2 number of public of public keys</td>
<td>true/false</td>
<td>多重签名</td>
</tr>
<tr>
<td>OP_CHECKMULTISIGVERIFY</td>
<td>175</td>
<td>0xaf</td>
<td>x sig1 sig2 ... number of signatures pub1 pub2 number of public of public keys</td>
<td>true/false</td>
<td>与OP_CHECKMULTISIG一样，但之后执行OP_VERIFY</td>
</tr>
<tr>
<td>OP_VERIF</td>
<td>101</td>
<td>0x65</td>
<td>--</td>
<td>--</td>
<td>交易无效，即使发生在未执行的OP_IF分支</td>
</tr>
<tr>
<td>OP_VERNOTIF</td>
<td>102</td>
<td>0x66</td>
<td>--</td>
<td>--</td>
<td>交易无效，即使发生在未执行的OP_IF分支</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">2.比特币脚本支付有哪些类型</h2>

<h3 id="toc_6">付款到公钥哈希</h3>

<p>（Pay-to-Public-Key-Hash）<br/>
这种交易的脚本类型，在<a href="./15358583883222.html#%E4%BA%A4%E6%98%93%E7%9A%84%E8%84%9A%E6%9C%AC%E5%88%9D%E7%AA%A5">一篇对比特币交易的理解-交易的脚本初窥</a>)有具体的说明</p>

<h3 id="toc_7">多重签名</h3>

<p>多重签名脚本设置了一个条件，其中N个公钥被记录在脚本中，并且至少有M个必须提供签名来解锁资金。也称为&quot;m-n方案&quot;，其中n是密钥的总数，m是验证签名所需的签名数量<br/>
设置M-N多重签名条件的锁定脚本的一般是：</p>

<pre><code class="language-text">M &lt;public key 1&gt; &lt;public key 2&gt; ... &lt;public key N&gt; N OP_CHEACKMULTSIG
</code></pre>

<p>或者说3个存档公钥中的任意2个相一致的私钥签名组合给予解锁，输入和输出组合将形成一个验证的脚本：</p>

<pre><code class="language-text">0 &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public key A&gt; &lt;Public key B&gt; &lt;Public key C&gt; 3 OP_CHECKMULTSIG
</code></pre>

<blockquote>
<p>multsig解锁脚本如果看到一个额外的0开始，其目的是解决一个bug，即保证例子中3个私钥签名（其中2个有效签名，其中一个为0的无效签名）对应3个公钥用于检查多重签名，从而保证脚本不产生bug</p>
</blockquote>

<h3 id="toc_8">付款到脚本P2SH</h3>

<p>（Pay-to-Script-Hash）<br/>
P2SH在2012年被作为一种新型，强大，且能大大简化复杂交易脚本类型而引入的<br/>
上面我讲述了多重签名的应用，虽然满足资金的多方管理，但是同时带来很多的不便，例如必须在客户付款前将该脚本发送给每一个客户，而且每一位客户也必须使用特制能产生交易脚本的比特币钱包的软件，每位顾客还得学会如何利用脚本来完成交易。</p>

<p>另外，脚本可能包含特别长的公钥，最终的交易也比较大给客户的造成费用的负担</p>

<p>最后，一个长的交易脚本记录在UTXO中，这种复杂输出脚本使得实际交易中变的困难重重</p>

<p>P2SH，正是为了解决这一实际的难题而引入的，复杂的锁定脚本被电子指纹（密码学中的哈希）所取代，在P2SH交易中，锁定脚本由哈希运算后的20个字节的散列值取代，被称为赎回脚本，因为它在系统中是赎回时出现而不是以锁定脚本模式出现的</p>

<p>1.不含P2SH的复杂脚本</p>

<table>
<thead>
<tr>
<th>脚本</th>
<th>code</th>
</tr>
</thead>

<tbody>
<tr>
<td>锁定脚本</td>
<td>2 pubkey1 pubkey2 pubkey3 pubkey4 pubkey5 5 OP_CHECKMULSIG</td>
</tr>
<tr>
<td>解锁脚本</td>
<td>sig1 sig2</td>
</tr>
</tbody>
</table>

<p>2.P2SH的复杂脚本</p>

<table>
<thead>
<tr>
<th>脚本</th>
<th>code</th>
</tr>
</thead>

<tbody>
<tr>
<td>赎回脚本</td>
<td>2 pubkey1 pubkey2 pubkey3 pubkey4 pubkey5 5 OP_CHECKMULSIG</td>
</tr>
<tr>
<td>锁定脚本</td>
<td>OP_HASH160 <20-btye hash of 赎回脚本> OP_EQUAL</td>
</tr>
<tr>
<td>解锁脚本</td>
<td>sig1 sig2 赎回脚本</td>
</tr>
</tbody>
</table>

<p>3.对比上面两种类型脚本</p>

<p>可以看出复杂的脚本不会在锁定脚本中显示，而且对于其它的随机节点也方便了验证，同时也减少了字节，同时使得给矿工的交易费用从发送发转移到收款方，复杂的计算及验证的工作也是由发送发转移到收款方</p>

<p>4.多重签名的脚本详解（m-n Multisig）<br/>
 用一个交易作为示例：<a href="http://blockmeta.com/tx/c8bc7cff08249ea5f9970e15be64259b0135b0b6e37f1f9f088a719508cbd8bc">http://blockmeta.com/tx/c8bc7cff08249ea5f9970e15be64259b0135b0b6e37f1f9f088a719508cbd8bc</a><br/>
c8bc7cff08249ea5f9970e15be64259b0135b0b6e37f1f9f088a719508cbd8bc </p>

<ul>
<li>3Ae2TYfyHvwH11pUy6HaK7rBYn9GfGZ3Fk（Input）</li>
<li>17EFZ829NBT2WETLj3wJ5YUfXVaGckuUgs（Input） </li>
<li>1BQpsoxUq7N5Hv57QCnzLBbZSHGtqafaFy（Output） </li>
<li>3Ae2TYfyHvwH11pUy6HaK7rBYn9GfGZ3Fk（Output）<br/></li>
</ul>

<p>第一个输入</p>

<pre><code class="language-text">00 （OP_FALSE，约定为P2SH方式）
48 （第1个签名的字节数)
304502210080075aa29c42f8062f75cf6ab32004944417af974775581719008052c78719710220409fee54c6ddf2ca83e090077e443f95b427a63cc1ad87fca2625951b789d1c2 (第1个签名）
01 （约定所签名的数据为HASH_ALL（tx))
49（第2个签名的字节数)
3046022100b61d8f206d17efd6db32dad106f754f231ee8a16882929b1eb39a58bfd36b39e022100c62cff92dd6fb22b373025fc9b87044cf1b33502acc9de707e5f54d1c8a042a7 （第2个签名）
01 （约定所签名的数据为HASH_ALL（tx))
47 （支付合同脚本的字节数）
52 （OP_2, 表明m-n签名中的m = 2)
21  (第1个公钥的字节数）
0293baf0397588acc1aba056e868fd188dc0eea7554b45370aae862f9d2493a4c1
21  (第2个公钥的字节数）
020ab7517cf22a46b503ee8dcae7f9f109ec4cd19f0ab9d77c89c607554f3d5aa9（第一个公钥）
52（OP_2, 表明m-n签名中的n = 2, 说明这是一个2-2签名)
ae（OP_CHECKSIGVERIFY)
</code></pre>

<p>第二个输入</p>

<pre><code class="language-text">48 （签名的字节数）
304502203fe5f04a013512a4773414b25edc8c7915473dd5cf87bc73d28e1aaffdb4d14f022100e16156d526d1498f2cf5eb02d53e02f7fd5cf1dfdd25e4b032fdc5c59c9fd27b （签名）
01 （约定所签名的数据为HASH_ALL（tx))
21 （公钥的字节数）
0203635e5c184951e14fcfecc83b15960594f4fceec729e09a4a517b0a03a7f4b9 （公钥）
</code></pre>

<p>第一个输出</p>

<pre><code class="language-text">OP_DUP
OP_HASH160
14 (字节数，0x14 = 20L, 网站在显示时省略了这一字节）
7232ca33e0797405a512fa872934cd922c812965 （20字节的哈希值）
OP_EQUALVERIFY
OP_CHECKSIG
</code></pre>

<p>第二个输出</p>

<pre><code class="language-text">OP_HASH160
14 (字节数，0x14 = 20L, 网站在显示时省略了这一字节）
622854939d571b63df97f47e8302b700ab2932b6 （20字节的哈希值）
OP_EQUAL
</code></pre>

<h4 id="toc_9">P2SH地址</h4>

<p>将脚本哈希编译为一个地址，P2SH地址是基于Base58编码的一个含有20个字节的哈希，P2SH地址隐藏了所有的复杂性，因此，运用进行支付的人将不会看到脚本</p>

<h4 id="toc_10">P2SH的优点</h4>

<ol>
<li>交易输出中，复杂的脚本由简短的电子指纹取代，使得交易代码变短</li>
<li>脚本能编译为地址，支付指令发出着和支付者的比特币钱包不需要复杂的工序就可执行</li>
<li>将构建脚本的重担转移至接收方，而非发送发</li>
<li>将长脚本数据存储负担从输出方（存储UTXO，影响内存）转移至输入方（存储在区块链里面）</li>
<li>将长脚本数据存储的重担从当前转移到未来</li>
<li>交易费从发送发转移至接收方，接收方使用该币资金时，必须含有赎回脚本</li>
</ol>

<h4 id="toc_11">赎回脚本和标准确认</h4>

<blockquote>
<p>P2SH锁定脚本包含一个赎回脚本的哈希，该脚本对于赎回脚本本身未提供任何的描述。P2SH交易即便在赎回脚本无效的情况下也会被认为有效，如果处理不当，可能会出现一个事故，即你的比特币可能会锁死在P2SH这个交易中，导致你以后再也不能花费这笔交易了，同时也会导致内存中UTXO变大 </p>
</blockquote>

<p>支付到脚本的类型验证的方式：<br/>
1.验证赎回脚本和锁定脚本是否匹配<br/>
2.通过后在执行赎回的脚本</p>

<blockquote>
<p>以下是执行的脚本顺序<br/>
例如：<br/>
赎回脚本： <2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG><br/>
锁定脚本：OP_HASH160  &lt;赎回脚本 scriptHash&gt; OP_EQUEAL<br/>
解锁脚本：Sig1 Sig2 <2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG><br/>
那么整个脚本执行入栈的依次顺序是：<br/>
赎回脚本入栈，锁定脚本入栈，解锁脚本入栈</p>
</blockquote>

<h3 id="toc_12">如何存储数据到区块链上</h3>

<p>将数据存储到区块链上，同时也叫做数据零知识证明</p>

<h4 id="toc_13">多重签名</h4>

<p>Multi-Signaturnes，可用部分公钥作为数据的存储，又称为外带数据<br/>
例如：一个交易的输出为：</p>

<p><strong>1 Publickey OP_HASH160(外带数据) 2 OP_CHECKMULTSIGN</strong></p>

<p>该交易的输出证明，只有有人证明该公钥对应的私钥拥有者，就说明了外带数据是由私钥拥有者所有</p>

<h4 id="toc_14">数据记录输出（OP_RETURN操作符）</h4>

<p>2013年，比特币协议引进了一项新的功能，即创建一种名为OP_RETURN的交易，可以嵌入40个字节小段数据（目前已经是80字节）</p>

<p>这个功能最初是把情景信息加入比特币交易中，比如配送信息等，后来发展为更具有创造性的用法，即创造最小量的交易（0.00000001BTC的交易费），并且可以嵌入任何你想放进去的信息</p>

<p>例如：交易号：793430203367a558101239a5719043230205367a558100039a57190</p>

<p><strong>OP_RETURN 43430205367a558100039a57190</strong></p>

<blockquote>
<p>利用这个功能产生一个有趣的应用就是，存在性证明(Proof of Existence) <br/>
不过需要注意的是，OP_TRUEN交易输出是不进入UTXO集合中，所以是无法再次交易的<br/>
一个标准的交易（通过isStandard()函数检验的）只能有一个RETURN输出，不过单个OP_RETURN可以和任意类型的输出交易进行组合</p>
</blockquote>

<h2 id="toc_15">3.时间锁</h2>

<p>时间锁（timelocks）是允许一段时间后才允许支出交易；<br/>
比特币一开始有一个交易级的时间锁定功能（nlocktime）<br/>
2015年低和2016年中推出了两个新的时间锁定功能，提供UTXO级别的时间锁定功能，分别是<strong>CHECKLOCKTIMEVERIFY</strong>和<strong>CHECKEQUENCEVERIFY</strong></p>

<h3 id="toc_16">交易锁定时间</h3>

<p>nlocktime，大多数交易中将其设置为零，表示即时的传播和执行<br/>
如果nlocktime不为零，低于5亿，则将其解释为块的高度，这意味着小于该区块高度交易无效<br/>
如果超过了5亿，它被解释为Unix时间戳，并且小于当前时间戳交易无效</p>

<p>通常nlocktime和<strong>sequence</strong>同时使用</p>

<blockquote>
<p>交易的序列，该值的范围是0-232 -1，该值往往是和下面的locktime配合使用的，当sequence=232 -1，则就忽略locktime的功能；</p>

<p>当locktime是未来的时间，且sequence&lt;232 -1的时候，那么到了loacktime的时候，以sequence最大的准，其它的交易将会从交易池中移除</p>
</blockquote>

<p>关于交易时间限制的问题说明<br/>
例如小宋给小李签署一笔交易，将交易的时间nlocktime设定为3个月</p>

<blockquote>
<ul>
<li>在3个月内，小李不能使用该笔交易</li>
<li>小李可以在3个月之后接受交易</li>
</ul>
</blockquote>

<p>然而</p>

<blockquote>
<ul>
<li>小宋可以再创建一个交易，双重花费相同的输入，而不需要锁定时间，因此小宋可以在3个月过去之前花费相同的UTXO</li>
<li>小李不能保证小宋不会这样做</li>
</ul>
</blockquote>

<p>所以唯一保证的是小李3个月之内无法兑换此交易，也就是说不能保证小李一定可以得到资金，为了实现这样的保证，时间限制必须放在UTXO本身上，并称为锁定脚本的一部分，而不仅仅是交易。</p>

<h3 id="toc_17">检查锁定时间验证</h3>

<p>check lock time verify (CLTV)<br/>
2015年12月，引入了一种新的形式的时间锁进行比特币的分叉升级，CLTV允许再应用时间锁的方式上具有更大的灵活性，简单的说通过在输出的赎回脚本中添加CLTV操作码来限制输出，从而只能在指定的时间后使用。</p>

<blockquote>
<p>当nlocktime是交易级时间锁定时，CLTV则是基于输出的时间锁</p>
</blockquote>

<pre><code class="language-text">OP_DUP HASH160 &lt;public key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<pre><code class="language-text">&lt;now + 3 months&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP 
OP_DUP HASH160 &lt;public key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<p>CLTV不会取代nlocktime的，而是限制特定的UTXO;<br/>
CLTV和nlocktime同时使用的话，CLTV的时间小于等于nLocktime的时间，CLTV和nlocktime（块的高度和Unix纪元时间）保持相同的格式</p>

<p>CLTV和nlocktime的场景组合使用，从使用的角度来说交易锁的级别是大于输出锁的</p>

<ul>
<li><p>场景描述：A给B转账，要求立即到账，但是B需要3个月后方花费这笔交易（解决双花问题）</p>
<pre><code class="language-text">交易锁nlocktime = 0，CLTV = Now+3Month
</code></pre></li>
<li><p>场景描述：A给B转账，要求3个月后到账</p>
<pre><code class="language-text"> 方式一：交易锁nlocktime = Now+3Month，CLTV = Now+3Month（CLTV可加，可不加）
 方式二：交易锁nlocktime = Now+3Month，nsenquece &lt; 2^32 -1（容易出现双花）
</code></pre></li>
<li><p>场景描述：A给B转账，要求3个月后到账，之后B要求立即到账</p>
<pre><code class="language-text">1.创建第一个交易，
交易锁nlocktime = Now+3Month，nsenquece &lt; 2^32 -1         <br/>
2.再创建一个相同的交易，但是设置nsenquece为最大<br/>
交易锁nlocktime = Now+3Month，nsenquece = 2^32 -1，CLTV=0（如有输出的锁就要忽略）    <br/>
那么交易锁碰到nsenquece最大的时候，就表示立即执行交易，忽略nlocktime
</code></pre></li>
</ul>

<h3 id="toc_18">相对时间锁</h3>

<p>nlocktime和CLTV都是绝对锁，他们是指定的绝对时间点，接下来讲解的是相对锁定</p>

<p>2016年5月份相对时间锁的软分叉升级的共识规则<br/>
相对锁的主要应用场景，是允许两个或多个相互依赖的交易链在一次，同时对依赖与从先前交易的确认所经过的时间的一个交易施加时间约束。<br/>
也就是说，在UTXO被记录在块之前，时钟不开始计数，这个功能在双向状态通道和闪电网络中特币有用，后面我们会讲到</p>

<p>相对时间锁，同时也具有交易级别和脚本级别的操作码<br/>
交易级相对时间锁对应每个交易输入中设置的交易字段nSequence的值共识规则实现<br/>
脚本级相对时间锁定使用OP_CHECKSEQUENCVERIFY(CSV)操作码来实现的</p>

<h4 id="toc_19">nSequence相对时间锁</h4>

<p>nSequence设计的初心说想让交易能在内存中修改，可惜后面从未使用过，使用nSequence这个字段，如果输入的交易序列小于2<sup>32</sup> (0xffffffff)，就表示尚未“确认”的交易</p>

<p>这样交易将在内存池中保存，直到被另一交易消耗相同输入并具有较大的nSequence值代替，一旦出现了nSequence=2<sup>32</sup> -1，那么将被视为“最终确定”，将会立即进入打包到矿池</p>

<p>新的共识规则中适用于任何包含nSenquence值小于2<sup>31</sup> 的输入的交易，如果没有设置为最 高有效的那么他表示一个“相对锁定时间”的标志，否则nSenquence保留其它用途</p>

<blockquote>
<p>我理解相对时间锁的概念是“当交易完成后（且从输入中引用了UTXO的时间算起），第多少块才有效”<br/>
nSequence是每个输入的字段，因此交易中可能包含任何数量的时间锁定输入，所有的这些必须具有足够的的时间以使用交易有效</p>
</blockquote>

<p>nSequence值是以块或秒为单位指定的，与nLocktime中适用的格式略有不同，nSequence类型设置了在第23个最低有效位（ 2<sup>22</sup> ）,如果设置了类型标志，则nSquence值将被解释为512秒的倍数，否则被解释为块数</p>

<p>当将nSequence解释为相对时间锁定时，只考虑16个最低有效位。一旦评估了标志（位32和23），nSequence值通常用16位掩码（例如nSequence＆0x0000FFFF）“屏蔽”。</p>

<table>
<thead>
<tr>
<th><font color=red>31</font></th>
<th>30</th>
<th>——</th>
<th>23</th>
<th><font color=Orange>22</font></th>
<th>21</th>
<th>——</th>
<th>16</th>
<th><font color=DodgerBlue>15</font></th>
<th><font color=DodgerBlue>--</font></th>
<th><font color=DodgerBlue>0</font></th>
</tr>
</thead>

<tbody>
</tbody>
</table>

<p>第32位标记nSequence为相对时间<br/>
第23位标记是类型，为1则表示512秒的倍数<br/>
第0-15最低的16位表示具体的值<br/>
所有nSquence的值的范围0-65536块或(0-33554432秒)</p>

<p>补一下基础知识</p>

<blockquote>
<p>位的运算，及标志位与掩码？<br/>
六大位运算符号（<code>&amp;</code><code>|</code><code>～</code><code>^</code><code>&lt;&lt;</code><code>&gt;&gt;</code>）</p>
</blockquote>

<p><strong>标志位</strong>：二进制在特定位设置为1</p>

<p><strong>掩码</strong>：取出二进制指定范围的位置，例如：掩码0x0000ff00表示对一个32位整数的8-15位进行操作<br/>
a = 0x12345678; mask = 0x0000ff00;<br/>
将a进行掩码求与操作，然后在进行右移8位得出操作的值，(a &amp; mask) &gt;&gt; 8</p>

<pre><code class="language-text">    1 
&lt;&lt;  7
-------------------- 向左移7位（ 相当于乘以 2^7 ）
    1000 0000

    1 
&gt;&gt;  7
-------------------- 向右移7位
    0000 0001

    0000 0011
&amp;   0000 0101
-------------------- 与运算 （相当于相乘）
    0000 0001
    
    0000 0011
|   0000 0101
-------------------- 或运算 （相当于相加）
    0000 0111
    
    0000 0011
^   0000 0101
-------------------- 异或运算（相当于相减取正），用于交换两个变量值
    0000 0110

~   0000 0101
-------------------- 非运算 （相当于取反）
    1111 1010
</code></pre>

<h4 id="toc_20">带CSV的相对时间锁</h4>

<p>是一个脚本操作码用于相对时间的锁定，它利用脚本中的nSequence值，该操作码是OP_CHECKEQUENCEVERIFY，在UTXO的赎回脚本中评估时，CSV操作码仅允许在输入nSquence值大于或等于CSV参数的交易中进行消耗，实质上限制了UTXO的消耗，直到UTXO开采时间过一定数量的块或秒</p>

<p>应用场景是，当几个（已经形成链）交易被保留为“脱链”时，创建和签名这几个（已经形成链）交易但不传播的时，CSV的相对时间锁就有用了，在父交易已被传播，直到消耗完相对锁定时间，才能使用子交易</p>

<h3 id="toc_21">中位时间过去Median-Time-Past</h3>

<p>作为激活相对时间锁定的一部分，时间锁定（绝对和相对）的时间方式也发了变化，在比特币中墙上时间(wall time)和共识时间之间存在微妙但非常显著的差异</p>

<p>比特币是一个分散的网络，这意味着每个参与者都有自己的时间，网络延迟必须考虑到每个节点的角度，最终，所有内容都被同步，以创建一个共同的区块链</p>

<p>为了加强时间的安全性，增加了“中位时间过去(Median-time-past)”的共识测量机制，通过最后11个块的时间戳并计算其中位数作为“中位时间过去”的值，这个中间时间就变成了共识时间，并被用余所有的时间计算</p>

<h3 id="toc_22">针对费用狙击（Fee Sniping）的时间锁定</h3>

<p>费用狙击是一种理论攻击情形，矿工试图从将来的块（挑选手续费较高的交易）重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力</p>

<p>例如，假设存在的最高是块100000，如果不是试图把100001号的矿区扩大到区块链，那么一些矿工会试图重新挖矿100000，这些矿工可以选择在候选块100000中包括的任何有效的交易（尚未开采），当他们重新创建块100000时，本质上可以将交易从“现在”提取到重写的“过去”中</p>

<p>为了防止“费用狙击”，当Bitcoin Core钱包创建交易时，默认情况下，它使用nLocktime将他们限制为“下一个块”，Bitcoin Core在任何创建的交易上将nLocktime设置为100001，在正常的情况下，交易只能包含在1000001块中，但是区块链分叉攻击的情况下，由于所有的交易被时间锁阻止于100001，所以矿工无法从筹码中提取高额的交易，他们只能在当时的任何交易中重新挖矿100000，这导致实质上不会获取新的费用，为了实现这一点，Bitcoin Core将所有的新交易的nLocktime设置为<current block #+ 1>，并将所有输入的上nSequence设置为0xFFFFFFFFE以启用nLocktime</p>

<h2 id="toc_23">4.具有流量控制的脚本（条件字句）</h2>

<p>比特币的条件操作码允许我们构建一个具有两种解锁方式的赎回脚本，这取决于苹果逻辑条件的TRUE/FALSE，例如如果x为true，则赎回脚本为A,else赎回脚本为B,此外表达的条件可以无限期的“嵌套”</p>

<pre><code class="language-text">大多数编程语言的流控制
if（条件）:
    code to run when 条件 is true
else:
    code to run when 条件 is false
code to run in either case
 
 
BitCoin脚本流控制
条件
IF
    code to run when 条件 is true
ELSE
    code to run when 条件 is false
ENDIF
code to run in either case
</code></pre>

<h3 id="toc_24">VERIFY操作码的条件字句</h3>

<p>在脚本中一个条件是任何以VERIFY结尾的操作码，表示如果评估的条件不为TRUE，脚本的执行将立即终止，并且该交易被视为无效。<br/>
与提供代替执行路径的IF字句不同，VERIFY后缀充当保护字句，只有在满足前提的条件下才会继续；</p>

<p>例如，脚本需要用户小a的签名和产生的特定哈希前的数据DATA</p>

<p>方式一：</p>

<pre><code class="language-text">赎回脚本：OP_HASH160 &lt; DATA hash &gt; OP_EQUALVERIFY &lt; a&#39; pubkey &gt; OP_CHECKSIG

锁定脚本： OP_HASH160 &lt;20-btye hash of 赎回脚本&gt; OP_EQUAL

解锁脚本：&lt; a&#39; sig &gt; &lt; 赎回脚本 &gt;
</code></pre>

<p>方式二：</p>

<pre><code class="language-text">锁定的脚本如下：
OP_HASH160 &lt;预期的 HASH&gt; OP_EQUAL
IF
    &lt;a&#39;s pubkey&gt; OP_CHECKSIG
ENDIF


解锁的脚本如下：
&lt;a&#39;s Sig&gt;  &lt;hash DATA&gt;
</code></pre>

<p>方式三：</p>

<pre><code class="language-text">赎回脚本：
OP_HASH160 &lt;预期的 HASH&gt; OP_EQUAL
IF
    &lt;a&#39;s pubkey&gt; OP_CHECKSIG
ENDIF


锁定脚本：
OP_HASH160 &lt;赎回脚本 HASH&gt; OP_EQUAL


解锁脚本：
&lt;a&#39;s Sig&gt;  OP_HASH160 &lt;预期的 HASH&gt; OP_EQUAL IF &lt;a&#39;s pubkey&gt; OP_CHECKSIG ENDIF
</code></pre>

<h3 id="toc_25">在脚本中使用流控制</h3>

<p>在脚本流量控制一个非常常见的用途是构建一个提供多个执行路径的赎回脚本，每个脚本都有一种不同的赎回UTXO的方式</p>

<p>例如：1-of-2多重的签名</p>

<pre><code class="language-text">赎回的脚本：
IF
    &lt;A&#39;s Pubkey&gt; OP_CHECKSIG
ELSE
    &lt;B&#39;s Pubkey&gt; OP_CHECKSIG
ENDIF

解锁的脚本：
&lt; A&#39;s Sig &gt; 1
&lt; B&#39;s Sig &gt; 0

</code></pre>

<p>再例如一个复杂的多重嵌套脚本case</p>

<pre><code class="language-text">赎回脚本：
IF
    script A
ELSE
    IF
        script B
    ELSE
        script C
    ENDIF
ENDIF

解锁的脚本：
scriptB解锁的路径，1 0
scriptC解锁的路径，0 0
scriptA解锁的路径，1
</code></pre>

<blockquote>
<p>注意解锁脚本的路径，由于解锁的脚本是先入栈的，所有交互的路径感觉是反着呢</p>
</blockquote>

<h2 id="toc_26">5.复杂的脚本的运用</h2>

<h3 id="toc_27">一个case</h3>

<p>例如，某公司希望创建灵活的规则建立公司的资本账户，多重签名计划的参与者Song，以及他的两个合伙人Zhang和Li，以及公司的律师Lawyer，创建不同级别的授权，具体取决于时间锁定；<br/>
具体的业务如下：<br/>
三个合伙人根据多数规则作出决定，因此三种中两个必须同意，然而如果他们的钥匙有问题，他们希望律师能够用三个合伙人获取签名之一收回资金，最后，如果所有的合伙人一段时间都不可用或无行为能力，他们希望律师能够直接管理该账户</p>

<pre><code class="language-text">赎回脚本：

IF
    IF
        2
    ELSE
        &lt;30 days&gt; OP_CHECKQUENCEVERIFY DROP
        &lt;Lawyer pubkey&gt; OP_CHECKSIGVERIFY
        1
    ENDIF
        &lt;Song&#39;s pubkey&gt; &lt;Zhang&#39;s pubkey&gt; &lt;Li&#39;s pubkey&gt; 3 OP_CHECKMULTSIG
ELSE
    &lt;90 days&gt; OP_CHECKQUENCEVERIFY DROP   //注意这是一个相对的时间脚本锁
    &lt;Lawyer pubkey&gt; OP_CHECKSIG
ENDIF


解锁脚本：

路径1: &lt;Lawyer Sig&gt; 0 (90天之后，律师放可以单独的花费该笔资金)
路径2: 0 &lt;Song&#39;s Sig&gt; &lt;Zhang&#39;s Sig&gt; 1 1 (三个合伙人中有两个签名就可以花费该笔资金)
路径3: 0 &lt;Song&#39;s Sig&gt; &lt;Lawyer Sig&gt; 0 1 (超过三十天，律师签名加上三个合伙人中任意一个人就可以花费该笔资金)
 
</code></pre>

<p>针对上面的Case，一些扩展的思考及实现</p>

<ul>
<li>为什么要用nSequence相对时间锁？而不用脚本CHECKLOCKTIMEVERIFY(CLTV)普通锁？</li>
<li>CHECKSIG操作码后缀为什么有些有VERIFY，有些没有？</li>
<li>如果律师失去钥匙，资金是否流失？</li>
<li>如果91天过去了，律师是否可以直接花费该笔资金？</li>
<li>合作伙伴如何每隔29天或89天“重置”一次，以防止律师获取资金？</li>
<li>是否可以让律师有备份的钥匙？</li>
</ul>

<h3 id="toc_28">case问题解答</h3>

<ol>
<li><p>为什么要用nSequence相对时间锁？而不用脚本CHECKLOCKTIMEVERIFY(CLTV)普通锁？</p>
<blockquote>
<p>相对时间锁，是说明了该交易的输出已经进入了UTXO集合了</p>
</blockquote></li>
<li><p>CHECKSIG操作码后缀为什么有些有VERIFY，有些没有？</p>
<blockquote>
<p>所有操作码包含VERIFY，就是当执行验证失败则会中断下面等流程，标记交易失败</p>
</blockquote></li>
<li><p>如果律师失去钥匙，资金是否流失？</p>
<blockquote>
<p>仅仅律师丢了私钥是不会造成资金丢失的，但是如果3个合伙人中丢了两把钥匙，那么这笔资金就永远无法花费了，也就是等同了资金的流失；</p>
</blockquote>
<p>增加一定时间后，任何一个合伙人私钥签名即可花费该笔交易，具体实现如下：</p>
<pre><code class="language-text">赎回脚本：
IF<br/>
    IF<br/>
        2<br/>
    ELSE<br/>
        IF<br/>
            &lt;30 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
            &lt;Lawyer pubkey&gt; OP_CHECKSIGVERIFY<br/>
        ELSE<br/>
            &lt;60 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
        ENDIF<br/>
            1<br/>
    ENDIF<br/>
        &lt;Song&#39;s pubkey&gt; &lt;Zhang&#39;s pubkey&gt; &lt;Li&#39;s pubkey&gt; 3 OP_CHECKMULTSIG<br/>
ELSE<br/>
    &lt;90 days&gt; OP_CHECKQUENCEVERIFY DROP   //注意这是一个相对的时间脚本锁<br/>
    &lt;Lawyer pubkey&gt; OP_CHECKSIG<br/>
ENDIF   <br/>
解锁脚本：<br/>
路径1：0 &lt; Song&#39;s Sig &gt; &lt; Lawyer&#39;s Sig &gt;  1 0 1<br/>
如果超过30天了，那么律师私钥签名+三个合伙人中其中任何一个私钥签名，即可花费该笔交易<br/>
路径2：0 &lt; Song&#39;s Sig &gt; 0 0 1<br/>
如果超过60天了，那么三个合伙人中其中任何一个私钥签名，即可花费该笔交易
</code></pre></li>
<li><p>如果91天过去了，律师是否可以直接花费该笔资金？</p>
<blockquote>
<p>是的</p>
</blockquote></li>
<li><p>合作伙伴如何每隔29天或89天“重置”一次，以防止律师获取资金？</p>
<blockquote>
<p>目前还没有太好解决思路？</p>
</blockquote></li>
<li><p>是否可以让律师有备份的钥匙？</p>
<blockquote>
<p>可以让律师有两把钥匙，作为其中一个备份</p>
</blockquote>
<pre><code class="language-text">赎回脚本：
IF<br/>
    IF<br/>
        2<br/>
    ELSE<br/>
        IF<br/>
            &lt;30 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
            1 &lt;Lawyer pubkey&gt; &lt;Lawyer2 pubkey&gt; 2 OP_CHECKMULTSIGVERIFY<br/>
        ELSE<br/>
            &lt;60 days&gt; OP_CHECKQUENCEVERIFY DROP<br/>
        ENDIF<br/>
            1<br/>
    ENDIF<br/>
        &lt;Song&#39;s pubkey&gt; &lt;Zhang&#39;s pubkey&gt; &lt;Li&#39;s pubkey&gt; 3 OP_CHECKMULTSIG<br/>
ELSE<br/>
    &lt;90 days&gt; OP_CHECKQUENCEVERIFY DROP   //注意这是一个相对的时间脚本锁<br/>
    1 &lt;Lawyer pubkey&gt; &lt;Lawyer2 pubkey&gt; 2 OP_CHECKMULTSIG<br/>
ENDIF   <br/>
解锁脚本：<br/>
路径1：0 &lt; Song&#39;s Sig &gt; 0 &lt; Lawyer&#39;s Sig &gt;  1 0 1<br/>
如果超过30天了，那么律师私钥签名+三个合伙人中其中任何一个私钥签名，即可花费该笔交易<br/>
路径2：0 &lt; Lawyer&#39;s Sig &gt; 0<br/>
如果超过了90天后，律师可以用其中两把私钥中任意一个都可以完成私钥签名，即可花费该笔交易
</code></pre></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358584238347.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358583883222.html">
                
                  <h1>一篇对比特币交易的理解</h1>
                  <div class="a-content">
                      
		                  <div class="a-content-img">
                      		<img src="asset/img/0d31920756c0c05f083afc22379b5057.png" />
                      	  </div>
		              
                      <div class="a-content-text">
                        
                        	要想了解比特币，首先要知道是如何交易的，以及底层的结构和数据脚本是如何实现的；本文主要是对比特币交易系统的分析，分别从钱包的创建，交易的数据结构，挖矿交易，普通交易的数据分析；
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358583883222.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15350288973049.html">
                
                  <h1>分布式共识算法思考</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15350288973049.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348504281449.html">
                
                  <h1>比特币的开发环境配置</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348504281449.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348479167321.html">
                
                  <h1>比特币</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>概述：从别从，比特币的发展历史，，，，，，</p>

<hr/>

<h3 id="toc_0">历史</h3>

<ul>
<li>2008年，Bitcoin是由署名Satoshi Nakamoto发明的，他出版了为“Bitcoin:A Peer-to-Peer Electronic Cash System”;结合了b-money和hashCash的发明，创建一个完全去中心化的电子现金系统，不依赖中央机构进行的货币发行或结算和验证交易。</li>
<li>2009年，基于中本聪（传言是澳大利亚人，目前尚未被确认身份）发布的参考实施指南，之后由许多程序员进行修订。</li>
<li>2014年，比特币背后的区块链技术被大家关注，并正式的发布分布式记账本（Distributed Ledger）技术的革新浪潮。</li>
</ul>

<hr/>

<h3 id="toc_1">什么是比特币</h3>

<p>本质上就是一个去中心化账本<br/>
一种建立于p2p和密码学基础上的数据货币<br/>
密码学和分布式系统的组合产物<br/>
比特币的特点：</p>

<ul>
<li>去中心化的点对点网络<br/>
比特币的传输协议，或者是说脚本的传输协议</li>
<li>区块链<br/>
存放交易的数据链 <br/>
块，时间戳，难度系数，交易集合</li>
<li>共识机制<br/>
货币的发行规则（是一种奖励规则，解决货币的流通的问题）<br/>
交易的验证规则（交易引用，解决交易双花问题）<br/>
交易数据一致性（去中心化，引入工作量证明，解决由谁来写入区块链的问题） <br/>
脚本的网络传输协议（解决个个节点之间的区块同步问题） </li>
<li>货币所有权的证明<br/>
公钥，私钥，匿名化交易</li>
</ul>

<hr/>

<h3 id="toc_2">比特币是如何发行的</h3>

<p>比特币没有特定的发行机构，而是依靠一套去中心化的发行机制，逐步将比特币发行出去；比特币系统相当于一个去中心化的大账本，每个区块就是这一个账本中的一页，系统自动生成比特币作为奖励激励矿工参与记账；<br/>
每十分钟全体矿工一起计算一道问题，最先算出的矿工获得记一页账的权利，经过100个块确认后，矿工将自动的获得一定数量的比特币；<br/>
最开始记账一次获取50个比特币，每记21万页账（大约需要4年）记账的奖励就会减少一半，直到大约2140年，比特币无法细分，直至发行完毕，总量2100万枚；</p>

<hr/>

<h3 id="toc_3">什么是比特币的钱包</h3>

<p>比特币的钱包是存放用户的私钥和公钥的；和现实的钱包不太一样</p>

<h5 id="toc_4">1.密码学的基础</h5>

<ul>
<li><p>哈希运算<br/>
又称为散列函数，把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值</p>
<blockquote>
<p>f（x）不可逆，只能正向运算<br/>
    极难找到hash值相同的<br/>
    正向运算快，即时原文很大<br/>
    无论原文多大，都压缩固定位数的16进制</p>
</blockquote></li>
<li><p>非对称加密<br/>
密钥是一对，拥有公开密钥和私有密钥，随机生成一个私钥，然后通过椭圆曲线算法得到公钥</p>
<blockquote>
<p>公钥加密，只有私钥可解开<br/>
    私钥签名，可以用公钥验证</p>
</blockquote></li>
<li><p>base58和base58cheack<br/>
为了更简洁的表示长串的数字，使用更少的符号来表示<br/>
比特币钱包的地址<br/>
比特币钱包的验证</p></li>
</ul>

<h5 id="toc_5">2.钱包都有哪些类型</h5>

<ul>
<li>全节点钱包客户端</li>
<li>简单支付验证客户端SPV</li>
<li>基于第三方客户端程序接口</li>
</ul>

<h5 id="toc_6">3.生成自己的钱包</h5>

<blockquote>
<p>私钥，随机32位字符（256位随机数）<br/>
公钥，椭圆曲线加密SECP2561算法<br/>
公钥哈希值，SHA256(公钥)<br/>
公钥哈希值，ripemd160(公钥哈希值)<br/>
校验码，SHA256(SHA256(1个字节版本号0x00+公钥哈希值))，取前4个字节<br/>
base58(1个字节版本号0x00+公钥哈希值+校验码)<br/>
得到钱包地址</p>
</blockquote>

<h3 id="toc_7">比特币怎么完成交易的</h3>

<p>比特币系统雨传统的银行支付系统不同，是基于去中心化的信任，在比特币中取代了中央信任机构，信任通过各个节点之间的互相参与互相达成的； </p>

<ol>
<li><p>交易的概述</p>
<p>在比特币系统中由用户（通过私钥控制的钱包），将每一笔的交易广播到整个比特币的网络中，矿工通过竞争计算生成的每个节点达成的共识的区块（包含当前网络中所发生的所有的交易），然后将其区块同步到其它的节点；</p>
<p>比特币的持有者已授权把比特币转账给其他人，而持有者能够再次授权，转移给该比特币所有权链中的其他人，产生另一笔交易来花掉这些比特币，后面的持有者在花费比特币也是类似的方式；</p>
<p>整个交易的传递，其实就是所有权的证明转移，这就是为什么说，区块链实现的是价值的转移，而非单纯互联网信息传递；</p></li>
<li><p>块，交易结构己交易链的说明</p></li>
</ol>

<pre><code class="language-text"># pram 块的结构
type Block struct {
        hash               string       哈希
        confirmations      string       确认次数
        size               uint64       块的大小
        height             uint64       块的高度
        version            uint32       块的版本
        merkleroot         string       默克尔树（后期讲解）
        tx                 []           交易的详细信息集合
        time               uint32       块的时间
        nonce              uint32       随机数（最大2^32，后期讲解）
        bits               string       当前目标hash值
        difficulty         float64      难度系数（用于挖矿控制，后期讲解）
        previousblockhash  string       上一个区块的hash
}
 
# pram 交易的结构
type tx struct {
        hex                 string              交易的十六进制
        txid                string              交易的id
        version             uint64              版本号
        locktime            uint64              锁定时间（后期在脚本中会讲解）
        vin                 []                  交易的输入
        vout                []                  交易的输出
        blockhash           string              所在的块的hash
        confirmations       uint32              交易确认的次数
        time                uint32              交易的时间
        blocktime           uint32              所在快的时间
}

# pram 交易的输入（挖矿所得的币）结构
type vin_coinbase struct {
        coinbase            string              挖矿所得的备注说明
        sequence            uint32              序列
}

# pram 交易的输入（交易所得的币）结构
type vin_tx struct {
        txid                string             交易的id
        vout                uint32             交易的索引（和vout中的n对应）
        sequence            uint32             输入序列（后期在脚本中会讲解）
        scriptSig           map                解锁脚本
        {   
            asm =&gt; &quot;私钥签名&quot;,
            hex =&gt; &quot;16进制&quot;
        }
}

# pram 交易的输出结构
type vout struct {
        value               uint32           交易金额
        n                   uint32           交易引用索引           
        scriptPubKey        map              锁定脚本 
        {
            asm =&gt; &quot;脚本code&quot;,
            hex =&gt; &quot;签名验证16进制&quot;,
            reqSigs =&gt; &quot;签名个数，默认至少为1&quot;,
            type =&gt; &quot;pubkey:公钥验证，pubkeyhash:私钥签名验证&quot;,
            addresses =&gt; [&quot;钱包的地址&quot;]
        }                 
}
</code></pre>

<ol>
<li><p>首先如何获得第一个比特币</p>
<p>挖矿得到basecoin<br/>
场外交易</p></li>
<li><p>怎么计算余额</p>
<p>假设自己的钱包是全节点的客户端；</p>
<blockquote>
<p>得到自己的钱包地址</p>
</blockquote>
<p>遍历所有的区块，得到区块中的所有交易的输出 <br/>
匹配交易里面包含addresses字段，是一个数组结构（具体交易结构在交易细节中查看）<br/>
得到当前钱包地址匹配出来的交易，然后，在当前块中，查询是否有交易的输入包含该txid<br/>
如果没有包含，就加入未花费的交易(UTXO)的HashMap集合中<br/>
累加所有的未花费的交易(UTXO)的值，得到钱包中的余额</p>
<p>优化建议：</p>
<p><code>生成钱包时候，指定位数标记当前最大的区块高度（或时间戳）<br/>
    例如钱包的格式：1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA[37676/1535624845]<br/>
</code> </p>
<p>未花费的交易(UTXO)<br/>
交易没有被引用</p></li>
<li><p>怎么转账</p>
<p>组合UTXO，大于交易的金额</p></li>
<li><p>如何找零</p>
<p>将剩下的钱，转入自己的钱包中</p></li>
<li><p>交易费用</p>
<p>交易的小费是按照字节大小来计算的</p></li>
<li><p>完整交易的输入和输出</p>
<p>例如，用户a转账10个比特币给用户b<br/>
任何交易都有上一个交易的引用，或是说有多个输入或多个输出；</p>
<p>a用户给b用户转账的交易明细如下：<br/>
<strong>输入：</strong>解锁脚本(私钥验证签名)</p>
<blockquote>
<p>[<br/>
    a用户用自己的私钥，验证签名得到未花费的交易1,<br/>
    a用户用自己的私钥，验证签名得到未花费的交易2<br/>
]</p>
</blockquote>
<p><strong>输出：</strong>锁定脚本（转出公钥证明）</p>
<blockquote>
<p>[<br/>
    目标b用户的公钥，<br/>
    目标a用户的公钥（用于找零）<br/>
]</p>
</blockquote></li>
<li><p>交易的传输</p></li>
<li><p>交易的验证</p></li>
<li><p>挖矿写入区块链中</p></li>
<li><p>最终如何确认交易完成</p></li>
<li><p>b如何花费该笔交易</p></li>
</ol>

<h3 id="toc_8">交易的细节讲解</h3>

<p>生活中我们都有自己的银行账户，转账是在银行账户之间进行的。同样，比特币转账就是把比特币从一个比特币地址转移到另一个比特币地址上的过程。如果你想要转账比特币给别人，你需要在比特币交易平台、比特币钱包或者比特币客户端中，输入你的比特币地址、接收方地址、转账金额和手续费金额。确定支付后交易信息会在比特币网络进行全网广播。矿工每隔10分钟会将比特币网络中未被记账的交易打包进一个区块，这就完成了一次确认，此时比特币已转到对方账户。通常需要经过6次确认，确保交易记录不能被任何人窜改，转账才算真正完成。</p>

<ol>
<li><p>块的数据结构</p></li>
<li><p>交易的数据结构</p></li>
<li><p>交易费</p></li>
<li><p>如何找零</p></li>
<li><p>一个完整的交易例子说明</p></li>
</ol>

<h3 id="toc_9">挖矿的细节讲解</h3>

<p>挖矿是数字货币一个创新，解决了数据一致性的问题；<br/>
比特币通过挖矿产生，每10分钟，全网矿工一起计算一道算术题，谁先算出答案，就相当于挖到了这个区块，这个过程叫做挖矿；<br/>
那么是什么样的算术题呢？<br/>
首先，每个区块上有一难度系数，将随机产生hash256的值进行计算，需要小于该难度系数；<br/>
将交易信息+自增长的数字，进行hash256，得到64位的16进制，转换为二进制2<sup>256次方的值；</sup><br/>
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>
这是一个极大的值，例如随机产生一个2<sup>256次方的值都小于该值；</sup><br/>
为了增加计算的时间，我们将值缩小，例如：0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>
1 Khash/s = 1000 hash/s<br/>
1 Mhash/s = 1000 Khash/s<br/>
1 Ghash/s = 1000 Mhash/s<br/>
1 Shash/s = 1000 Ghash/s<br/>
1 PHash/s = 1000 Shash/s = 1000000000000000 hash/s <br/>
难度系数：<br/>
0x0000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>
nonce的最大值2<sup>32次方</sup><br/>
比特币里nonce的预设太小了。对于现在的挖矿难度，当交易的merkle tree给定后，在32bit的nonce里面找到解的概率忽略不计。一台专业矿机在秒为单位的时间内就能穷举完nonce的所有可能。nonce太小，Merkle tree root来凑。现在的做法是不断的改变coinbase交易，带动merkle tree变化，再循环穷举nonce。针对一个给定的merkle tree root，nonce穷举完了，还没找到解，接着改coinbase来换新的merkle tree root，开始新的nonce穷举，如此重复，直到找到解为止。<br/>
如何改变coinbase交易？<br/>
1000笔交易的顺序可能有，1000!个阶乘计算，这个数字是极其大的<br/>
预留了2<sup>32次方,那么最大的值是2<sup>224次方</sup></sup><br/>
<code>D*2^32/600<br/>
时间=难度*2^32/算力<br/>
</code> <br/>
随着运算的提高，难度系统也再增加，每2014块（两周）会调整一下，难度系数，确保产生的块平均维持在10分钟左右，不至于过快的将币挖完；</p>

<h3 id="toc_10">比特币的脚本讲解</h3>

<h3 id="toc_11">比特币的p2p网络</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348479167321.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348479167538.html">
                
                  <h1>区块链的基本概念</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">定义</h3>

<pre><code class="language-text">分布式的数据库
密码学和分布式系统的组合产物
基于共识机制，去中心化的公开数据库
</code></pre>

<h3 id="toc_1">特点</h3>

<ul>
<li><p>分布式（Distributed）</p></li>
<li><p>自治的（Autonomous）</p></li>
<li><p>按照合约执行的（Contractual）</p></li>
<li><p>可追溯的（Trackable）</p></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348479167538.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>我对区块链的理解</h1>
                <div class="site-des">对区块链的思考</div>
                <div class="social">







<a target="_blank" class="weibo" href="https://weibo.com" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:spzhongwin@google.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="poofAlgorithm.html"><strong>共识算法</strong></a>
        
            <a href="about.html"><strong>关于</strong></a>
        
            <a href="index.html"><strong>指引</strong></a>
        
            <a href="bit.html"><strong>比特币</strong></a>
        
            <a href="ethereum.html"><strong>以太坊</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15365050797831.html">一篇对数字签名的理解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15360563845824.html">关于</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358586085164.html">一篇对比特币的应用案例分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358585289735.html">一篇对比特币网络的理解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358584946404.html">一篇对比特币挖矿的理解</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2018
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>


<script type="text/javascript">
    var disqus_shortname = 'coderforart'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'coderforart'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
