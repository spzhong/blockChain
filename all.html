<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  我对区块链的理解
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="我对区块链的理解" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>

<link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermaid.css">
<!--        <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermadidstyle.css">-->
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/jquery.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/rawdeflate.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/encode64.js"></script>
            <script src="asset/sample-custom-html-charts/echarts.common.min.js"></script>
            <script src="asset/sample-custom-html-charts/mermaid.min.js"></script>
            <script type="text/javascript">
                $(function(){
                  var mwebii=0;
                  var mwebChartEleId = 'mweb-chart-ele-';
                  $('pre>code').each(function(){
                                     mwebii++;
                                     var eleiid = mwebChartEleId+mwebii;
                                     if($(this).hasClass('language-mermaid')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div id="'+eleiid+'"></div>').addClass('mermaid').html($(this).text()).insertAfter(ele);
                                     }else if($(this).hasClass('language-plantuml')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     var str = unescape(encodeURIComponent($(this).text()));
                                     var imgURL = "http://www.plantuml.com/plantuml/svg/"+encode64(deflate(str,9));
                                     var newEle = $('<div id="'+eleiid+'"><img src="'+imgURL+'" /></div>').insertAfter(ele);
                                     }else if($(this).hasClass('language-js-echarts')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div style="width: 100%;height:400px;" id="'+eleiid+'"></div>').insertAfter(ele);
                                     var myChart = echarts.init(document.getElementById(eleiid));
                                     try  {
                                     eval($(this).text());
                                     myChart.setOption(option);
                                     }catch(exception) {}
                                     }
                                     });
                  
                  mermaid.init({noteMargin: 10}, ".mermaid");
                  });
                </script>



  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">首页</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        <li id=""><a target="_self" href="about.html">关于</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 我对区块链的理解</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">首页</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        
        <li><a target="_self" href="about.html">关于</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="poofAlgorithm.html">共识算法</a></li>
        
            <li><a href="about.html">关于</a></li>
        
            <li><a href="index.html">指引</a></li>
        
            <li><a href="bit.html">比特币</a></li>
        
            <li><a href="ethereum.html">以太坊</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15385342635688.html">
                
                  <h1>以太坊虚拟机</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="https://www.jianshu.com/p/e45614c25b62?_t=1522874771">https://www.jianshu.com/p/e45614c25b62?_t=1522874771</a></p>

<ul>
<li>
<a href="#toc_0">比特币和以太坊的渊源</a>
</li>
<li>
<a href="#toc_1">区块链范式</a>
</li>
<li>
<a href="#toc_2">区块</a>
</li>
<li>
<a href="#toc_3">EVM设计于执行</a>
</li>
<li>
<a href="#toc_4">内存模型</a>
</li>
<li>
<a href="#toc_5">执行模型</a>
</li>
<li>
<a href="#toc_6">错误处理</a>
</li>
</ul>


<h2 id="toc_0">比特币和以太坊的渊源</h2>

<p>对币圈和链圈的人来说，Vitalik Buterin(1994年出生)是无可争议的大神。很多人可能不知道，V神作为早期比特币社区的活跃成员，一开始提议bitcoin需要开发通用的脚本语言来支持丰富功能的应用开发，但没有获得比特币开发团队的支持。于是重起炉灶，2013年发起以太坊项目，有了今天的繁荣的加密token、收藏品游戏、DAO。接下来，我们就先看看，V神不满的比特币脚本系统到底是什么样的？</p>

<blockquote>
<p>比特币的交易主要依据的UTXOs模型，而以太坊摒弃该模型，采用了类似的bmoney的账户范式</p>
</blockquote>

<h2 id="toc_1">区块链范式</h2>

<h2 id="toc_2">区块</h2>

<h2 id="toc_3">EVM设计于执行</h2>

<h2 id="toc_4">内存模型</h2>

<h2 id="toc_5">执行模型</h2>

<h2 id="toc_6">错误处理</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/10/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='ethereum.html'>以太坊</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15385342635688.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15365050797831.html">
                
                  <h1>一篇对数字签名的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>比特币是基于密码学的，密码学这门科学不仅包含被称之为“秘密写作的”加密学，也可以用来证明秘密的知识，而不会泄漏秘密（数字签名），或证明数据的真实性（数字指纹），接下来介绍一下比特币中来控制资金的所有权的密码学，包括了密钥，地址和钱包。</p>

<ul>
<li>
<a href="#toc_0">数字签名</a>
<ul>
<li>
<a href="#toc_1">简介</a>
</li>
<li>
<a href="#toc_2">公钥加密和加密货币</a>
</li>
<li>
<a href="#toc_3">私钥和公钥</a>
</li>
<li>
<a href="#toc_4">私钥</a>
</li>
<li>
<a href="#toc_5">公钥</a>
</li>
<li>
<a href="#toc_6">椭圆曲线密码学(Elliptic Curve Cryptography)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">比特币地址</a>
<ul>
<li>
<a href="#toc_8">Base58和Base58Check编码</a>
</li>
<li>
<a href="#toc_9">密钥格式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">用Python实现密钥和比特币地址</a>
</li>
<li>
<a href="#toc_11">高级密钥和地址</a>
</li>
</ul>


<h2 id="toc_0">数字签名</h2>

<h3 id="toc_1">简介</h3>

<p>比特币的所有权是通过数字密钥，比特币地址和数字签名来确定的，数字密钥实际上不是存储在网络中的，而是由用户独立生成的，存储在钱包文件中或是数据库中；密钥实现了比特币的许多趣味性，包括去中心化信任和控制，所有权认证和基于密码学证明的安全模型</p>

<p>大多数比特币交易都需要一个有效的签名才会被存储在区块链中，只有有效的密钥才能产生有效的数字签名，因此拥有-密钥就拥有了对该账户的比特币的控制权，那么交易中的见证数据证明了所用资金的真正归谁所有</p>

<p>密钥是成对出现的，有一个私钥和公钥所组成</p>

<p>首先我们先介绍密码学并解释比特币中使用的数学知识，然后了解密钥如何被产生的，存储和管理的，代表私钥和公钥，地址和脚本地址的各种编码格式，最后，说一下密钥和地址的高级用途：比特币靓号，多重签名以及脚本地址和纸钱包</p>

<h3 id="toc_2">公钥加密和加密货币</h3>

<p>公钥加密发明于20世纪70年代，它是计算机和信息安全的数学基础。<br/>
例如，素数幂和椭圆曲线乘法，这些函数都是不可逆的，很容易向一个方向计算，但是不可以向反方向倒推。比特币正使用椭圆曲线乘法作为公钥加密的基础</p>

<p>支付比特币时，比特币的当前所有者需要交易中提交其公钥和签名（每次交易的签名都不同，但均是同一个私钥生成的），所有比特币网络中的所有人都可通过提交的公钥和签名进行验证，并确认该交易是否有效，即支付者拥有该交易的比特币的所有权</p>

<blockquote>
<p>大多数比特币钱包工具为了方便将私钥和公钥以密钥对的形式存储在一起，然而公钥可以由私钥计算的到，所以只存储私钥即可</p>
</blockquote>

<h3 id="toc_3">私钥和公钥</h3>

<p>一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥，私钥(k)是一个数字，通常是随机选的，有了私钥通过椭圆曲线乘法这个单向加密的函数产生一个公钥，然后使用一个单向加密哈希函数生成比特币地址</p>

<p>为什么要使用非对称加密（公钥/私钥）？<br/>
非对称密码学适用性使得任何人都可以验证每笔交易的每个签名，同时确保只有私钥的所有者可以产生有效的签名</p>

<h3 id="toc_4">私钥</h3>

<p>私钥就是一个随机选出的数字而已。私钥必须始终保持机密，因为一旦泄漏给第三方，那么就相当于将该私钥下的控制的比特币所有权拱手于人；私钥还必须要备份，一旦丢失同理也是弃掉了将该私钥下的控制的比特币所有权</p>

<blockquote>
<p>私钥生成，随机256位的二进制数字（64位的16进制）</p>

<blockquote>
<p>2<sup>256</sup> 是一个非常大数字，用十进制表示的话大约10<sup>77</sup> ，而可见宇宙被估计只含有10<sup>80</sup> 个原子</p>
</blockquote>
</blockquote>

<h3 id="toc_5">公钥</h3>

<p>通过椭圆曲线乘法可以从私钥计算得到公钥，这个过程不可逆转：K = k*G (k是私钥，G被称为生成点点常数点，而K是所得的公钥)<br/>
通过私钥，可以计算得到公钥，但是由于过程不可逆，无法通过公钥得到私钥</p>

<h3 id="toc_6">椭圆曲线密码学(Elliptic Curve Cryptography)</h3>

<p>椭圆曲线加密法是一种基于离散对数问题的非对称加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。</p>

<blockquote>
<p>y<sup>2</sup> = x<sup>3</sup> + ax + b<br/>
<img src="media/15365050797831/20170801154403156.gif" alt="20170801154403156"/><br/>
备注：动态效果图参看<a href="https://blog.csdn.net/dianqu6970/article/details/76534222">椭圆曲线加密学习</a></p>
</blockquote>

<p><img src="media/15365050797831/121401537009791_.pic_hd.jpg" alt="121401537009791_.pic_hd"/></p>

<h2 id="toc_7">比特币地址</h2>

<p>以公钥K为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160哈希值，得到一个长度160位（20字节）的数字：</p>

<blockquote>
<p>A = RIPEMD160(SHA256(K))<br/>
  address = Base58 Encode(A)</p>
</blockquote>

<h3 id="toc_8">Base58和Base58Check编码</h3>

<p>为了更简洁方便表示长串的数字，使用更少的符号，许多计算机会使用一种以数字和字母组成的大于十进制的表示法；<br/>
Base64使用了26个大小写字母，10个数字及两个符号（+ /）<br/>
Base58是一种基于文本的二进制编码格式，这种编码格式不仅实现了数据压缩，保持了易读性，Base58不包含数字0，字母o，大小写i，以及+ / ，比Base64少了6个字符</p>

<p><img src="media/15365050797831/1411537524443_.pic_hd.png" alt="1411537524443_.pic_hd"/></p>

<h3 id="toc_9">密钥格式</h3>

<h2 id="toc_10">用Python实现密钥和比特币地址</h2>

<h2 id="toc_11">高级密钥和地址</h2>

<p><a href="https://blog.csdn.net/taifei/article/details/74382718">https://blog.csdn.net/taifei/article/details/74382718</a><br/>
<a href="https://blog.csdn.net/taifei/article/details/73880736">https://blog.csdn.net/taifei/article/details/73880736</a><br/>
<a href="https://blog.csdn.net/ztemt_sw2/article/details/81101717">https://blog.csdn.net/ztemt_sw2/article/details/81101717</a><br/>
<a href="https://github.com/cyhhao/eth-canvas">https://github.com/cyhhao/eth-canvas</a><br/>
<a href="https://blog.csdn.net/j3t9z7h/article/details/80970818">https://blog.csdn.net/j3t9z7h/article/details/80970818</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15365050797831.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15360563845824.html">
                
                  <h1>关于</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>人往往把自己置身于空闲中，有一种了然的焦虑，但遗弃了自我；</p>

<p>人往往把自己置身于忙碌中，有一种麻木的踏实，但丧失了真实；</p>

<p>那么如何完成真实的自我呢？<br/>
心之所向，然后有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦。</p>

<p>一个人要知道自己想要什么，并且坚定不移的去做，一直做，一直做。。。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='about.html'>关于</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15360563845824.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358586085164.html">
                
                  <h1>一篇对比特币的应用案例分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358586085164.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358585289735.html">
                
                  <h1>一篇对比特币网络的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1.P2P网络架构</a>
</li>
<li>
<a href="#toc_1">2.节点类型及角色</a>
</li>
<li>
<a href="#toc_2">3.扩展比特币网络</a>
</li>
<li>
<a href="#toc_3">4.比特币传播网络</a>
</li>
<li>
<a href="#toc_4">5.网络发现</a>
<ul>
<li>
<a href="#toc_5">p2p握手协议</a>
</li>
<li>
<a href="#toc_6">新节点如何找到对等体</a>
</li>
<li>
<a href="#toc_7">建立连接后地址的传播和发现</a>
</li>
<li>
<a href="#toc_8">异常连接</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">6.全节点</a>
</li>
<li>
<a href="#toc_10">7.交换“库存清单”</a>
</li>
<li>
<a href="#toc_11">8.P2P的连接到数据同步</a>
</li>
<li>
<a href="#toc_12">9.简易支付验证(SPV)节点</a>
<ul>
<li>
<a href="#toc_13">什么是SPV</a>
</li>
<li>
<a href="#toc_14">SPV技术原理</a>
</li>
<li>
<a href="#toc_15">如何验证支付交易</a>
</li>
<li>
<a href="#toc_16">SPV如何实现？</a>
</li>
<li>
<a href="#toc_17">引入SPV节点带来的风险</a>
</li>
<li>
<a href="#toc_18">如何解决引入SPV的风险</a>
</li>
</ul>
</li>
<li>
<a href="#toc_19">10.Bloom过滤器</a>
<ul>
<li>
<a href="#toc_20">什么是Bloom过滤器</a>
</li>
<li>
<a href="#toc_21">Bloom过滤器是如何工作的</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">11.SPV节点如何使用Bloom过滤器</a>
</li>
<li>
<a href="#toc_23">12.SPV节点和隐私</a>
</li>
<li>
<a href="#toc_24">13.加密和认证连接</a>
<ul>
<li>
<a href="#toc_25">Tor网络传输</a>
</li>
<li>
<a href="#toc_26">对等认证和加密</a>
</li>
</ul>
</li>
<li>
<a href="#toc_27">14.交易池</a>
</li>
<li>
<a href="#toc_28">15.DOS攻击（扩展阅读）</a>
<ul>
<li>
<a href="#toc_29">TCP三次握手</a>
</li>
<li>
<a href="#toc_30">常见的DOS攻击的方式</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.P2P网络架构</h2>

<p>P2P是指同一网络中的美态计算机都彼此对等，各个节点共同提供网络服务，每个网络节点以&quot;扁平(flat)&quot;的拓扑结构互相连通</p>

<p>P2P网络节点之间交互运作，协同处理，每个节点在对外提供服务的同时也是使用网络中其它节点提供的服务</p>

<p>对于比特币设计的一种点对点数字现金系统，它的网络架构即反应出其特性，通过维持一种扁平化网路共识，来实现去中心化的交易系统</p>

<p>“比特币网络”是按照比特币P2P协议运行的一系列节点的集合，除了比特币协议之外，比特币网络中也包含其它的协议<br/>
例如Stratum协议，就被应用于挖矿，以及轻量级或移动端的比特币钱包中。网关（gateway）路由服务器提供的这些服务协议</p>

<blockquote>
<p>例如：Stratum服务器通过Stratum协议将所有的Stratum挖矿节点连接至比特币主网络，并将Stratum协议桥连接(bridge)至比特币p2p协议之上</p>
</blockquote>

<p>我们所说的比特币网络是指“比特币P2P协议”，“矿池挖矿协议”，“Stratum协议”以及其它连接比特币系统组件相关协议的整体网络机构</p>

<h2 id="toc_1">2.节点类型及角色</h2>

<p>一个比特币全节点是有“路由”，“区块链数据库”，“挖矿”，“钱包”组成；</p>

<ul>
<li>标准客户端 </li>
<li>全部数据块节点 </li>
<li>仅挖矿 </li>
<li>轻量级钱包SPV</li>
<li>协议池服务</li>
<li>挖矿节点</li>
<li>轻量的底层钱包</li>
</ul>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Wallet</td>
<td>Miner</td>
<td rowspan=2>【标准客户端】<br>包含一个钱包，挖矿，全部的区块数据，p2p的网络路由节点</td>
</tr>
<tr>
<td>Block</td>
<td>NetWork</td>
</tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>--</td>
<td>--</td>
<td rowspan=2> 【全部数据块节点】<br>包含全部的区块数据，p2p的网络路由节点 </td>
</tr>
<tr>
<td>Block</td>
<td>NetWork</td></tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>--</td>
<td>Miner</td>
<td rowspan=2>【仅挖矿】<br>包含一挖矿，全部的区块数据，p2p的网络路由节点</td>
</tr>
<tr>
<td>Block</td>
<td>NetWork</td></tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Wallet</td>
<td>--</td>
<td rowspan=2> 【轻量级钱包SPV】<br>包含钱包，p2p的网络路由节点 </td>
</tr>
<tr>
<td>--</td>
<td>NetWork</td></tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Pool Server</td>
<td>Stratum Server</td>
<td>【协议池服务】<br> 网关路由器将比特币P2P网络连接到运行其他协议的节点，例如矿池挖掘节点或层节点</td>
</tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Miner</td>
<td>Miner</td>
<td rowspan=2> 【挖矿节点】<br> 包含一个挖矿的功能，没有区块链，包含一个底层协议节点或其它挖矿池的协议节点 </td>
</tr>
<tr>
<td>Stratum node</td>
<td>Pool node</td>
</tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Wallet</td>
<td>--</td>
<td rowspan=2> 【轻量的底层钱包】<br> 包含一个钱包和一个底层协议的网络节点 </td>
</tr>
<tr>
<td>--</td>
<td>StratumNode</td></tr>
</table>

<h2 id="toc_2">3.扩展比特币网络</h2>

<p>这张复杂的网路架构图我还没有仔细的分析？<br/>
<img src="media/15358585289735/135734wtwzoomwgbf2a4zb.png" alt="135734wtwzoomwgbf2a4zb"/></p>

<h2 id="toc_3">4.比特币传播网络</h2>

<p>比特币传播网络涉及到了底层网络架构的传输优化（建议了解即可）</p>

<p>比特币网络传播是一种尝试最新小化矿工之间的传输块的延迟网络</p>

<ol>
<li><p>为了延迟矿工之间快速同步块，该网络由世界各地的亚马逊web服务基础架构上托管的几个专门的节点，并且连接大多数矿工和采矿池</p></li>
<li><p>2016年比特币传播网络被替换成“Fast Internet Bitcoin Replay Engine”(FIBRE)</p></li>
<li><p>FIBRE是一种基于UDP的中继网络，可以中继节点网络内的块，FIBRE也是实现了compact(紧凑) block，进一步减少了传输的数据量和网络延迟</p></li>
<li><p>还有一个提案阶段中继网络是Falcon，使用“直通路由”而不是“存储转发”来减少延迟，通过传播块的部分，而不是等待知道接受到完成的块</p></li>
</ol>

<blockquote>
<p>补充一下什么是中继<br/>
中继（Relay）是连个交换中心之间的一条传输通路，中继线是承载多条逻辑链路的一条物理连接<br/>
在中继的无线系统中，每个用户只是在呼叫时才分配一个信道，一旦通过终止，原先占用的信道就立即回到可用信道库中</p>
</blockquote>

<pre><code class="language-text">物理层中继系统：转发器。
数据链路层中继系统：网桥
网络层中继系统：路由器
在网络层以上的中继系统称为网关，网关就是连接两备个网络的设备
</code></pre>

<p>无线路由器中继与桥接模式的区别？</p>

<p>中继模式，就是利用无线路由器之间的无线连接功能，将无线信号从一个中继点传递到下一个中继点，实现信号的增强，并形成新的无线覆盖区域，最终达到延伸无线网络的覆盖范围的目的。事实上，只要有两台支持中继功能的无线路由器，即可拓展网络覆盖范围。</p>

<p>中继和桥接功能对于无线用户的实际使用基本上是一样的，只是设备有所不同，并非所有无线路由器都可以桥接，无线路由桥接就是把无线路由器当中继器使用。桥接并非无线路由器的主要功能。使用中继模式时，网络SSID号均一致，而在桥接模式时，网络SSID号不同。</p>

<h2 id="toc_4">5.网络发现</h2>

<h3 id="toc_5">p2p握手协议</h3>

<p>当新的网络节点启动后，为了能够参与协同运作，必须发现网络中的其他比特币节点；<br/>
由于比特币网络的拓扑结构并不基于节点间的地理位置，因此各个节点之间的地理位置信息完全无关，会随机的选择网络中存在的比特币节点与之相连</p>

<p>节点通常采用了TCP协议，通常使用8333端口与已知的对等节点建立连接，在建立连接的时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通讯</p>

<pre><code class="language-javascript">version:{
    nVsersion:定义客户端所采用的比特币p2p协议的版本
    nLocalServices:[
        一组该节点支持的本地服务列表，当前仅支持NOED_NETWORK
    ]
    nTime:当前时间
    addrYou:当前节点可见的远程节点的IP地址
    addrMe:本地节点所发现的本机IP地址
    subver:指示当前节点运行的软件类型子版本号（例如：&quot;/Satoshi:0.9.2.1/&quot;）
    baseHeight:当前节点区块链的区块高度
}
</code></pre>

<p>版本信息始终是任何对等发送给另一个对等的第一条消息，接收版本消息的本地对等将检查远程对等体报告的nVersion，并确定远端对是否兼容，如果兼容则本地等将确认版本消息，并发送一个（ver）ack建立连接</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant a as NodeA
    participant b as NodeB
opt 节点A请求连接节点B
    a--&gt;&gt;b: 节点A的version
    b--&gt;&gt;b: 验证节点A的version
    b-&gt;&gt;a: 发送verack
end  
opt 节点B请求连接节点A
    b--&gt;&gt;a: 节点B的version
    a--&gt;&gt;a: 验证节点A的version
    a-&gt;&gt;b: 发送verack
end  
</code></pre>

<h3 id="toc_6">新节点如何找到对等体</h3>

<ol>
<li>使用多个“DNS种子”来查询DNS，这些DNS服务器提供比特币节点的IP地址列表，其中一些DNS种子提供了稳定的比特币侦听节点的静态IP地址列表，还有一些DNS种子是BIND，它从搜索器或长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集，在BitcoinCore客户端中，使用DNS种子的选项switch-dnsseed控制（默认设置为1，以使用DNS种子）</li>
<li>不知道网络的引导节点必须被给予至少一个比特币节点的IP地址，之后可以通过进一步来建立连接，命令参数-sendnode可用于连接到一个节点，仅用于将其作为种子</li>
</ol>

<h3 id="toc_7">建立连接后地址的传播和发现</h3>

<p>当建立一个或者多个连接后，新节点将一条包含自身的ip地址列表的addr消息发送给其它相邻的节点，相邻的节点再将此条addr消息依次转发给其它各自相邻的节点，从而保证新节点信息被多个节点接收，保证连接更稳定；<br/>
同时，新接入的节点可以向相邻节点发送getaddr消息，要求他们返回已知的对等节点的ip地址列表</p>

<p>由于节点可以随时的加入和离开，通讯路径是不可靠的，因此节点必须持续进行两项工作：在失去已有连接时发现新的节点，并在其他节点启动时为其提供帮助</p>

<p>一个节点无需连接大量的对等节点，在启动完成后，节点会记住它最新连接成功的对等节点，因此，当重新启动后它迅速与先前的对等节点网络重新建立连接，如果先前的网络无应答，则该节点可以使用种子节点进行重启动</p>

<p>bitcoin-cli getpeerInfo</p>

<pre><code class="language-javascript">{
    &quot;services&quot; : &quot;00000001&quot;,
    &quot;lastsend&quot; : 1405634126,
    &quot;lastrecv&quot; : 1405634127,
    &quot;bytessent&quot; : 23487651,
    &quot;bytesrecv&quot; : 138679099,
    &quot;conntime&quot; : 1405021768,
    &quot;pingtime&quot; : 0.00000000,
    &quot;version&quot; : 70002,
    &quot;subver&quot; : &quot;/Satoshi:0.9.2.1/&quot;,
    &quot;inbound&quot; : false,
    &quot;startingheight&quot; : 310131,
    &quot;banscore&quot; : 0,
    &quot;syncnode&quot; : true
},
{
    &quot;addr&quot; : &quot;58.23.244.20:8333&quot;,
    &quot;services&quot; : &quot;00000001&quot;,
    &quot;lastsend&quot; : 1405634127,
    &quot;lastrecv&quot; : 1405634124,
    &quot;bytessent&quot; : 4460918,
    &quot;bytesrecv&quot; : 8903575,
    &quot;conntime&quot; : 1405559628,
    &quot;pingtime&quot; : 0.00000000,
    &quot;version&quot; : 70001,
    &quot;subver&quot; : &quot;/Satoshi:0.8.6/&quot;,
    &quot;inbound&quot; : false,
    &quot;startingheight&quot; : 311074,
    &quot;banscore&quot; : 0,
    &quot;syncnode&quot; : false
  }
</code></pre>

<h3 id="toc_8">异常连接</h3>

<p>如果已建立的连接没有数据通信，所在的节点会定期发送信息以维持连接，如果节点持续某个连接长达90分钟没有任何的通信，它会被认为从网络中断开，因此，比特币网络会随时根据变化的节点及网络问题进行动态的调整，无需经过中心化的控制即可进行规模增减的有机调整</p>

<h2 id="toc_9">6.全节点</h2>

<p>全节点是指维持包含全部交易信息的完整区块链的节点，又称“完整区块链节点”，在比特币早起，所有的节点都是全节点；</p>

<p>完整区块链节点，从创始块到网络最新的区块，它可以独立自主的校验任何交易的信息</p>

<p>无需借助任何其他系统，就可以完全摆脱中心化管理，获得完全的独立自由</p>

<p>它的代价就是，需要大量的存储空间和内存空间</p>

<h2 id="toc_10">7.交换“库存清单”</h2>

<p>一个全节点连接到对等节点之后，第一件事要做就是构建完整的区块链，如果该节点不包含如何区块链信息，那么新节点需要从创始块开始的数十万块的全部内容下载到新的节点上；</p>

<p>同步区块的过程中从发送的version消息开始，上面包含区块链的高度（区块的数量），对等节点门会叫唤一个getBlocks消息，其中包含他们本地区块链顶端的哈希值，比较其顶端的区块可得到那个节点区块链更长</p>

<p>较长的节点会给短的节点发送invx（inventory库存）消息，将这些区块的哈希传播出去，缺少这些区块的节点便可以通过各自发送的getData消息请求得到全区块的信息</p>

<h2 id="toc_11">8.P2P的连接到数据同步</h2>

<p>首先，为了防止单个节点承受的压力，单个节点最多承受100个节点的对等网络连接</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant a as Node0
    participant b as Node1
    participant c as Node2
    participant d as ...
opt 1.互相握手ACK
    a--&gt;&gt;b: 节点的version
    b--&gt;&gt;b: 验证节点的version
    b-&gt;&gt;a: 发送verack
    c--&gt;&gt;d: 节点的version
    d--&gt;&gt;d: 验证节点的version
    d-&gt;&gt;c: 发送verack
end  

opt 2.􏱐􏴡􏱕􏱖􏲔􏱰􏲠􏱐􏴡􏱕􏱖􏲔􏱰􏲠互相传播地址
    a--&gt;&gt;b: 上报自己addr信息
    a--&gt;&gt;b: 获取节点getaddr信息
    a--&gt;&gt;d: 上报自己addr信息
    a--&gt;&gt;d: 获取节点getaddr信息
    d--&gt;&gt;c: 上报自己addr信息
    d--&gt;&gt;c: 获取节点getaddr信息
end

opt 3.互相􏱐􏴡􏱕􏱖􏲔􏱰􏲠􏱐􏴡􏱕􏱖􏲔􏱰􏲠同步区块
    a--&gt;&gt;b: 获取getblocks顶端区块的HASH值
    b--&gt;&gt;a: 获取getblocks顶端区块的HASH值
    b--&gt;&gt;b: 验证两个区块的高度
    b-&gt;&gt;a: 发送inv（高于节点0,哈希值列表）
    a--&gt;&gt;b: 通过缺少的hash值getdata
    a--&gt;&gt;c: 通过缺少的hash值getdata
    a--&gt;&gt;d: 通过缺少的hash值getdata
end
</code></pre>

<h2 id="toc_12">9.简易支付验证(SPV)节点</h2>

<p>Simplified Payment Verification</p>

<h3 id="toc_13">什么是SPV</h3>

<p>并非所有的节点都有能力存储完整的区块链，例如智能电话，平板电脑，嵌入式系统等等，对于这些设备，通过简化的支付验证(SPV)的方式进行工作，也称为“轻量级客户端”</p>

<p>SPV节点只需要下载区块头，而不用下载包含每个区块中的交易信息，由此产生的区块链的大小时完成区块链的1/1000左右，SPV节点不能构建所有可可用于消费的UTXO的全貌，这是因为他们并不知道网络上所有的交易完整信息</p>

<blockquote>
<p>网上说一个例子，每个全节点就像是一个陌生城市里的游客，他带着一张包含每条街道，每个地址的详细地图，而SPV节点就像这个陌生城市里游客只知道一条主干道的名称，通过随机询问该城市中陌生人来获取分段的道路指示；</p>
</blockquote>

<h3 id="toc_14">SPV技术原理</h3>

<p>通过merklr_root_hash（验证区块中所有的交易真实性）<br/>
取出当前交易所在的区块hash，然后分别从不同的完整的区块节点对应的，默克尔树的叶子hash，然后计算得到根hash，再然后对比本地的区块头中根hash，从而验证了该交易的合法性</p>

<p>按照中本聪的原文，这里有个细节需要注意，SPV指的是“支付验证“，而不是“交易验证”。这两种验证有很大区别。</p>

<ul>
<li><p>“交易验证”非常复杂，涉及到验证是否有足够余额可供支出、是否存在双花、脚本能否通过等等，通常由运行完全节点的矿工来完成。</p></li>
<li><p>“支付验证”则比较简单，只判断用于“支付”的那笔交易是否已经被验证过，并得到了多少的算力保护（多少确认数）。</p></li>
</ul>

<h3 id="toc_15">如何验证支付交易</h3>

<p>简易支付验证是通过参考交易在区块链中的深度，而不是高度，来验证它们；<br/>
一个完整拥有区块链的节点会构造一条验证链，这个链条是由区块链按时间倒序一直追溯到创始块的及交易组成，然后SPV节点会验证所有的区块链（但不是所有的交易），并且把区块链和有关交易链接起来</p>

<p>例如，一个全节点要检查第1000000号区块中的某个交易，它会把从该区块开始一直追溯到创始块，将所有的区块都链接起来，并建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。SPV节点则不能验证UTXO是否还未支付，相反的SPV节点会在该交易信息和它所在的区块之间用merkle路径建立一条链接，然后SPV节点一直处于等待的状态，至到1000000+6个块写入区块上，并通过确立交易的深度是在1000000-1000006块之下验证交易的有效性</p>

<p>如果一个交易实际上不存在，SPV节点不会误认为该交易存在于某区块中，SPV节点会通过请求merkle路径证明以及验证区块链中的工作证明，来证实交易存性，不过，一个交易的存在是可能对SPV节点“隐藏”的，这个漏洞会针对SPV节点的拒绝服务攻击或双重支付攻击，为了防御这些攻击，SPV节点需要随机链接到多个节点，以增加与至少一个可靠节点相链接的概率；这种随机链接的需求就意味着容易受到网络的分区攻击或Sybil攻击，在Sybil攻击中SPV节点被连接到虚假节点或虚假网络中，没鱼哦通向可靠节点或真正的比特币网络的连接</p>

<blockquote>
<p>Sybil攻击（女巫攻击）<br/>
在对等网络中，单个节点通常具有多个身份标示，通过控制系统的大部分节点来消弱冗余备份的作用<br/>
女巫攻击是在P2P网络中，因为节点随时加入退出等原因，为了维持网络稳定，同一份数据通常需要备份到多个分布式节点上，这就是数据冗余机制。女巫攻击是攻击数据冗余机制的一种有效手段。如果网络中存在一个恶意节点，那么同一个恶意节点可以具有多重身份，那么恶意节点比它还能分。这一分可好，原来需要备份到多个节点的数据被欺骗地备份到了同一个恶意节点（该恶意节点伪装成多重身份），这就是女巫攻击</p>
</blockquote>

<pre><code class="language-解决sybil攻击的方法有">1.工作量证明机制，即证明你是一个节点，是要用计算能力证明，这样极大地增加了攻击的成本
2.身份认证（基于第三方的身份认证和随机密钥分发验证的公钥体制的认证方式）
FISOS金链盟就是用，随机密钥分发验证的公钥体制的认证方式
</code></pre>

<h3 id="toc_16">SPV如何实现？</h3>

<pre><code class="language-mermaid">    graph TB
    根HASH --&gt; 区块全节点1
    根HASH --&gt; 区块全节点2
    区块全节点1 --&gt; 区块全节点3
    区块全节点1 --&gt; 区块全节点4
    区块全节点2 --&gt; 区块全节点5
    区块全节点2 --&gt; 区块全节点6
    区块全节点3 --&gt; 区块全节点7
    区块全节点3 --&gt; 区块全节点8
    区块全节点4 --&gt; 区块全节点9
    区块全节点4 --&gt; 区块全节点10 
    区块全节点5 --&gt; 区块全节点11
    区块全节点5 --&gt; 区块全节点12 
    区块全节点6 --&gt; 区块全节点13
    区块全节点6 --&gt; 区块全节点14 
    区块全节点7 --&gt; 第1笔交易的HASH
    区块全节点8 --&gt; 第2笔交易的HASH
    区块全节点9 --&gt; 第3笔交易的HASH
    区块全节点10 --&gt; 第4笔交易的HASH
    区块全节点11 --&gt; 第5笔交易的HASH
    区块全节点12 --&gt; 第6笔交易的HASH
    区块全节点13 --&gt; 第7笔交易的HASH
    区块全节点14 --&gt; 第7笔交易的HASH
    end  
</code></pre>

<p>如果想验证第一笔交易，那么需要查询节点8，节点4，节点2对应当前块所在的叶子节点的HASH</p>

<p>同理如果想验证第四笔交易，哪些需要查询节点9，节点3，节点2对应当前块所在的叶子节点的HASH</p>

<p>再然后，通过查询到的叶子节点的HASH，进行默克尔二叉树HASH运算，得到根HASH</p>

<h3 id="toc_17">引入SPV节点带来的风险</h3>

<p>隐私风险<br/>
SPV节点对特定数据的请求会无意中透漏了钱包里的地址信息，监控网络的第三方可以跟踪某个SPV节点上的钱包所请求的全部信息，并且利用交易信息把比特币地址和钱包用户关联起来，从而损害了用户的隐私</p>

<h3 id="toc_18">如何解决引入SPV的风险</h3>

<p>Bloom过滤器<br/>
通过一个采用概率而不是固定模式过滤的机制，允许SPV节点只接收交易信息的子集，同时不会精准的泄漏哪些它们的感兴趣的地址<br/>
接下来会深入的讲解Bloom过滤器</p>

<h2 id="toc_19">10.Bloom过滤器</h2>

<h3 id="toc_20">什么是Bloom过滤器</h3>

<p>是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法<br/>
它让用户在有效搜索关键词的同时保护了他们的隐私，这个方法解决了对等节点发送交易信息查询请求，同时交易的地址也不会暴露</p>

<p>之前一个陌生人到陌生城市找线路的例子，当陌生人询问“教堂23号在哪里”，其实不经意间暴露了自己的目的地，Bloom过滤器则是这样询问的，附近带有“堂”字的街道吗？或是以“堂”结尾或是以“教”开头的街道</p>

<h3 id="toc_21">Bloom过滤器是如何工作的</h3>

<p>实现的原理：由一个可变长度(N)的二进制数组（N位进制树构成的一个位域）和数量可变的(M)的一组哈希函数组成；<br/>
这些哈希函数的输出值始终在1和N之间，该数组与二进制数组相对对应，该函数位确定函数，也就是说任何一个使用相同Bloom过滤器的节点通过该函数能对特定输入得到同一个结果；Blomm过滤器的准确性和私密性通过改变长度(N)和哈希数量(M)来调节</p>

<p>位数组和k散列函数<br/>
1.位数组<br/>
初始化状态，BloomFilter是一个长度位M的位数组，每一位都置为0<br/>
2.添加元素（k个独立的hash函数）<br/>
添加元素时，对x进行k个哈希函数得到的k个哈希值，对其进行M求余，对应的bit位设置为1<br/>
3.判断元素是否存在<br/>
判断y是否属于这个集合，对y使用k个哈希函数得到的k个哈希值，对M求余，所对应的位置都是1，则认为y属于该集合（可能存在误判），否则就认为y不属于该集合</p>

<p>BloomFilter（布隆过滤）算法   </p>

<pre><code class="language-text">已知参数列表如下：
m 位数组的长度
n 加入其中元素的数量
k 哈希函数的个数
f 错误率
</code></pre>

<p>公式( 1 - (1 - 1/m)<sup>kn</sup> )<sup>k</sup> ≈ (1 - e<sup>-kn/m</sup> )<sup>k</sup></p>

<p>加入m和n是固定的值的时候，能够使f最小化的k为<br/>
(m/n)ln(2) ≈ 9m/13n ≈ 0.7m/n</p>

<p>此时给出的f为<br/>
f = (1/2)<sup>k</sup> ≈ 0.6185<sup>m/n</sup></p>

<p>根据以上公式，对于任意给定的f<br/>
n = m ln(0.6185)/ln(f)</p>

<p>需要k个hash来达成目标<br/>
k = -ln(f)/ln(2)</p>

<p>由于k必须是整数，还应该使用上面的公私求得实际的错误率<br/>
f = (1-e<sup>-kn/m</sup> )<sup>k</sup></p>

<p>使用Hash函数的个数，位数组的大小来降低失误率。</p>

<p><code>以下的运用场景还需要待研究</code></p>

<p>具体参考<a href="https://blog.csdn.net/zdxiq000/article/details/57626464">大量数据去重：Bitmap和布隆过滤器(Bloom Filter)</a></p>

<p>可以使用JDK自带的BitSet来实现，但存在两个问题：OOM和持久化问题。<br/>
结合Redis的BitMap能够解决，唯一需要注意的是Redis的BitMap只支持2<sup>32</sup> 大小，对应到内存也就是512MB,数组的下标最大只能是2<sup>32-1</sup> 。不过这个限制可以通过构建多个Redis的Bitmap通过hash取模的方式分散一下即可。万分之一的误判率，512MB可以放下2亿条数据。<br/>
好了，扯了这么多，贴代码！(注：在MagnusS/Java-BloomFilter的基础上加上了Redis持久化的实现)</p>

<pre><code class="language-java">@Component
public class BloomFilter&lt;E&gt; {

    @Autowired
    private RedisTemplate&lt;String, E&gt; redisTemplate;

    @Value(&quot;${bloomfilter.expireDays}&quot;)
    private long expireDays;

    // total length of the Bloom filter
    private int sizeOfBloomFilter;
    // expected (maximum) number of elements to be added
    private int expectedNumberOfFilterElements;
    // number of hash functions
    private int numberOfHashFunctions;
    // encoding used for storing hash values as strings
    private final Charset charset = Charset.forName(&quot;UTF-8&quot;);
    // MD5 gives good enough accuracy in most circumstances. Change to SHA1 if it&#39;s needed
    private static final String hashName = &quot;MD5&quot;;
    private static final MessageDigest digestFunction;

    // The digest method is reused between instances
    static {
        MessageDigest tmp;
        try {
            tmp = java.security.MessageDigest.getInstance(hashName);
        } catch (NoSuchAlgorithmException e) {
            tmp = null;
        }
        digestFunction = tmp;
    }

    public BloomFilter() {
        this(0.0001, 600000);
    }

    /**
     * Constructs an empty Bloom filter.
     *
     * @param m is the total length of the Bloom filter.
     * @param n is the expected number of elements the filter will contain.
     * @param k is the number of hash functions used.
     */
    public BloomFilter(int m, int n, int k) {
        this.sizeOfBloomFilter = m;
        this.expectedNumberOfFilterElements = n;
        this.numberOfHashFunctions = k;
    }

    /**
     * Constructs an empty Bloom filter with a given false positive probability.
     * The size of bloom filter and the number of hash functions is estimated
     * to match the false positive probability.
     *
     * @param falsePositiveProbability is the desired false positive probability.
     * @param expectedNumberOfElements is the expected number of elements in the Bloom filter.
     */
    public BloomFilter(double falsePositiveProbability, int expectedNumberOfElements) {
        this((int) Math.ceil((int) Math.ceil(-(Math.log(falsePositiveProbability) / Math.log(2))) * expectedNumberOfElements / Math.log(2)), // m = ceil(kn/ln2)
                expectedNumberOfElements,
                (int) Math.ceil(-(Math.log(falsePositiveProbability) / Math.log(2)))); // k = ceil(-ln(f)/ln2)
    }

    /**
     * Adds an object to the Bloom filter. The output from the object&#39;s
     * toString() method is used as input to the hash functions.
     *
     * @param element is an element to register in the Bloom filter.
     */
    public void add(E element) {
        add(element.toString().getBytes(charset));
    }

    /**
     * Adds an array of bytes to the Bloom filter.
     *
     * @param bytes array of bytes to add to the Bloom filter.
     */
    public void add(byte[] bytes) {
        if (redisTemplate.opsForValue().get(RedisConsts.CRAWLER_BLOOMFILTER) == null) {
            redisTemplate.opsForValue().setBit(RedisConsts.CRAWLER_BLOOMFILTER, 0, false);
            redisTemplate.expire(RedisConsts.CRAWLER_BLOOMFILTER, expireDays, TimeUnit.DAYS);
        }

        int[] hashes = createHashes(bytes, numberOfHashFunctions);
        for (int hash : hashes) {
            redisTemplate.opsForValue().setBit(RedisConsts.CRAWLER_BLOOMFILTER, Math.abs(hash % sizeOfBloomFilter), true);
        }
    }

    /**
     * Adds all elements from a Collection to the Bloom filter.
     *
     * @param c Collection of elements.
     */
    public void addAll(Collection&lt;? extends E&gt; c) {
        for (E element : c) {
            add(element);
        }
    }

    /**
     * Returns true if the element could have been inserted into the Bloom filter.
     * Use getFalsePositiveProbability() to calculate the probability of this
     * being correct.
     *
     * @param element element to check.
     * @return true if the element could have been inserted into the Bloom filter.
     */
    public boolean contains(E element) {
        return contains(element.toString().getBytes(charset));
    }

    /**
     * Returns true if the array of bytes could have been inserted into the Bloom filter.
     * Use getFalsePositiveProbability() to calculate the probability of this
     * being correct.
     *
     * @param bytes array of bytes to check.
     * @return true if the array could have been inserted into the Bloom filter.
     */
    public boolean contains(byte[] bytes) {
        int[] hashes = createHashes(bytes, numberOfHashFunctions);
        for (int hash : hashes) {
            if (!redisTemplate.opsForValue().getBit(RedisConsts.CRAWLER_BLOOMFILTER, Math.abs(hash % sizeOfBloomFilter))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if all the elements of a Collection could have been inserted
     * into the Bloom filter. Use getFalsePositiveProbability() to calculate the
     * probability of this being correct.
     *
     * @param c elements to check.
     * @return true if all the elements in c could have been inserted into the Bloom filter.
     */
    public boolean containsAll(Collection&lt;? extends E&gt; c) {
        for (E element : c) {
            if (!contains(element)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Generates digests based on the contents of an array of bytes and splits the result into 4-byte int&#39;s and store them in an array. The
     * digest function is called until the required number of int&#39;s are produced. For each call to digest a salt
     * is prepended to the data. The salt is increased by 1 for each call.
     *
     * @param data   specifies input data.
     * @param hashes number of hashes/int&#39;s to produce.
     * @return array of int-sized hashes
     */
    public static int[] createHashes(byte[] data, int hashes) {
        int[] result = new int[hashes];

        int k = 0;
        byte salt = 0;
        while (k &lt; hashes) {
            byte[] digest;
            synchronized (digestFunction) {
                digestFunction.update(salt);
                salt++;
                digest = digestFunction.digest(data);
            }

            for (int i = 0; i &lt; digest.length / 4 &amp;&amp; k &lt; hashes; i++) {
                int h = 0;
                for (int j = (i * 4); j &lt; (i * 4) + 4; j++) {
                    h &lt;&lt;= 8;
                    h |= ((int) digest[j]) &amp; 0xFF;
                }
                result[k] = h;
                k++;
            }
        }
        return result;
    }

    public int getSizeOfBloomFilter() {
        return this.sizeOfBloomFilter;
    }

    public int getExpectedNumberOfElements() {
        return this.expectedNumberOfFilterElements;
    }

    public int getNumberOfHashFunctions() {
        return this.numberOfHashFunctions;
    }

    /**
     * Compares the contents of two instances to see if they are equal.
     *
     * @param obj is the object to compare to.
     * @return True if the contents of the objects are equal.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final BloomFilter&lt;E&gt; other = (BloomFilter&lt;E&gt;) obj;
        if (this.sizeOfBloomFilter != other.sizeOfBloomFilter) {
            return false;
        }
        if (this.expectedNumberOfFilterElements != other.expectedNumberOfFilterElements) {
            return false;
        }
        if (this.numberOfHashFunctions != other.numberOfHashFunctions) {
            return false;
        }
        return true;
    }

    /**
     * Calculates a hash code for this class.
     *
     * @return hash code representing the contents of an instance of this class.
     */
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 61 * hash + this.sizeOfBloomFilter;
        hash = 61 * hash + this.expectedNumberOfFilterElements;
        hash = 61 * hash + this.numberOfHashFunctions;
        return hash;
    }

    public static void main(String[] args) {
        BloomFilter&lt;String&gt; bloomFilter = new BloomFilter&lt;&gt;(0.0001, 600000);
        System.out.println(bloomFilter.getSizeOfBloomFilter());
        System.out.println(bloomFilter.getNumberOfHashFunctions());
    }
}
</code></pre>

<h2 id="toc_22">11.SPV节点如何使用Bloom过滤器</h2>

<h2 id="toc_23">12.SPV节点和隐私</h2>

<p>SPV的节点隐私比整个节点更弱，SPV节点接收与其钱包中的地址相关的经过过滤的列表，所有说整体上减少了所有者的隐私。</p>

<p>Bloom过滤器是减少隐私损失的一种方式，即时使用过滤器，对手监控SPV客户端的流量或直接连接到它的P2P网络中的节点可以随时随地收集足够的信息来了解SPV客户端钱包中的地址</p>

<h2 id="toc_24">13.加密和认证连接</h2>

<p>比特币节点网络通讯是加密的，P2P网络隐私和安全性有两种方案Tor传输和P2P认证和加密</p>

<h3 id="toc_25">Tor网络传输</h3>

<p>Tor代表是洋葱路由网络，是一个软件项目和网络，通过提供匿名，不可追踪和隐私的随机网络路径提供数据的加密和封装</p>

<blockquote>
<p>洋葱路由器是一个类似于P2P原理的代理服务器，所有安装了洋葱路由的用户既是代理服务器的使用者也是代理服务器的提供者，洋葱路由器是由志愿者，花费自己的带宽建立起来的。</p>
</blockquote>

<h3 id="toc_26">对等认证和加密</h3>

<p>BIP-150提供了可选的对等认证，允许节点使用ECDSA和私钥对对方身份进行身份验证<br/>
BIP-151支持了两个节点之间的所有通信的协商加密<br/>
不过这两种方案目前还尚未在BicoinCore实施</p>

<p>BIP-150和BIP-151允许用户运行连接到受信任的完整节点的SPV客户端，使用加密和身份证来保护SPV客户端的隐私</p>

<h2 id="toc_27">14.交易池</h2>

<p>在比特币网络中几乎每一个节点都会维护一份未确认的交易的临时列表，他被称为内存池和交易池。<br/>
节点们利用这个池来追踪记录哪些被网络所知晓，但是还未被区块链所包含的交易；<br/>
例如，保存用户钱包的节点会利用这个交易池来记录哪些网络已经接收但还未被确认的，属于该用户钱包的预支付信息</p>

<p>随着交易被接收和验证，他们被添加到交易池并通知相邻节点处，从而传播到到网络中</p>

<p>有些节点的实现，还维护一个单独的孤立交易池，如果一个交易的输入与某未知的交易有关，如与缺失的夫交易相关，该孤立交易就会被暂时存储在孤立的交易池中至到父交易的信息到达</p>

<p>当一个交易被添加到交易池中，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出（子交易），任何匹配的孤立交易会被进行验证；如果验证有效，他们会从孤立交易池中删除，并添加到交易池中，使以其夫交易开始链变的完整；<br/>
对新加入交易池的交易来说，他不再是孤立交易，前述的过程重复递归寻找进一步的后代，知道所有的后代都被找到，通过这一个过程，一个父交易的到达把整个链中的孤立交易和它们的父交易重新结合再一起，从而触发了整条交易链进行级链重构</p>

<p>交易池和孤立交易池都是存储在本地内存中，并不是存储永久性存储设备，它是随网络传入的消息动态填充，节点启动时，两个池子都是空闲的，随着网络中新交易不断被接收，两个池逐渐被填充</p>

<p>有些客户端还维护一个UTXO数据库，也成为UTXO池，是区块链中所有为支付交易输出的集合，UTXO感觉与交易池相似，但它代表了不同的数据集，UTXO池不同与交易池和孤立交易池的地方，它在初始化时不为空，而是包含了数以百万计的为支付的交易输出条目，有些条目的历史可以追溯到2009年。UTXO池可能被安置在本地内存或者作为一个包含索引的数据库安置在永久性存储设备中</p>

<p>交易池和孤立交易池代表是单个节点的本地视角，取决于节点的启动时间或重启时间，不同的节点两个池内容可能有很大的差别，相反的，UTXO池代表是网络的突显共识，因此不同节点间的UTXO池的内容差别不大。此外，交易池和孤立交易池只包含未确认交易，而UTXO池只包含已确认的交易</p>

<h2 id="toc_28">15.DOS攻击（扩展阅读）</h2>

<p>Dos是一对一<br/>
DDos是分布式多个节点对抗一个节点</p>

<h3 id="toc_29">TCP三次握手</h3>

<p>完成三次握手，客户端于服务器开始传送数据</p>

<ul>
<li>第一次握手<br/>
建立连接时，客户端发送SYN(syn=j)包到服务器，并进入SYN_SENT状态，等待服务器确认 </li>
<li>第二次握手<br/>
服务器收到SYN包，必须确认客户的syn(ack=j+1),同时自己也发送一个SYN包（syn=k）,即syn+ack包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手<br/>
客户端收到服务器的SYN+ACK包，向服务器端发送确认ACK(ack=k+1),此包发送完毕，客户端和服务器进行ESTABLISHEN(TCP连接成功)状态</li>
</ul>

<blockquote>
<p>SYN:同步序列编号（Synchronize Sequence Numbers）  </p>
</blockquote>

<pre><code class="language-mermaid">sequenceDiagram
participant a as 客户主机
participant b as 服务器主机
a-&gt;&gt;b: 连接请求（SYN=1,seq=client_isn） 
b-&gt;&gt;a: 授予连接（SYN=1,seq=client_isn）\n ack=client_isn+1
a-&gt;&gt;b: 确认（SYN=0,seq=client_isn+1）\nack=server_isn+1
</code></pre>

<h3 id="toc_30">常见的DOS攻击的方式</h3>

<ol>
<li>SYN FLOOD<br/>
利用服务器的连接缓冲区，设置TCP的Header,向服务器不断的成倍的发送有SYN标志的TCP请求，当服务器收到的时候，都认为没有建立起来的连接请求，于是排队到缓冲区队列中</li>
<li>IP欺骗DOS攻击<br/>
这种攻击是利用RST位来实现，假设有一个合法的用户(1.1.1.1)已经同服务器建立了正常的连接，攻击者构造攻击的TCP数据，伪装自己的IP(1.1.1.1),并向服务器发送一个带有RST位的TCP数据段，服务器收到后会认为1.1.1.1连接有错误，就会清空缓冲区的建立好的连接</li>
<li>带宽DOS攻击<br/>
如果你的连接带宽足够大而服务器又不是很大，可以发送大量的请求，来消耗服务器的缓冲区消耗服务器的带款</li>
<li>自身消耗的DOS攻击<br/>
这种攻击的方式是利用了老式的系统（win95）自身的BUG,攻击者伪装成自己的服务器端的IP端口，发送给主机，使得主机给自己发送TCP请求和连接，至到把资源耗光</li>
<li>塞满服务器的硬盘<br/>
发送垃圾邮件（前提邮件服务器和WEB服务器放在一起）<br/>
日志记录爆满（入侵者构造大量的错误的信息发送出来）</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358585289735.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358584946404.html">
                
                  <h1>一篇对比特币挖矿的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358584946404.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358584238347.html">
                
                  <h1>一篇对比特币脚本的理解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	一篇对比特币脚本的理解
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358584238347.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15358583883222.html">
                
                  <h1>一篇对比特币交易的理解</h1>
                  <div class="a-content">
                      
		                  <div class="a-content-img">
                      		<img src="asset/img/0d31920756c0c05f083afc22379b5057.png" />
                      	  </div>
		              
                      <div class="a-content-text">
                        
                        	要想了解比特币，首先要知道是如何交易的，以及底层的结构和数据脚本是如何实现的；本文主要是对比特币交易系统的分析，分别从钱包的创建，交易的数据结构，挖矿交易，普通交易的数据分析；
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15358583883222.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15353573374570.html">
                
                  <h1>拜占庭将军(BPFT)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='poofAlgorithm.html'>共识算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15353573374570.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15353573030349.html">
                
                  <h1>股份授权证明机制(DPOS)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='poofAlgorithm.html'>共识算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15353573030349.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15353572275978.html">
                
                  <h1>工作量证明(POW)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="https://www.jianshu.com/p/8c8cedc84220">https://www.jianshu.com/p/8c8cedc84220</a><br/>
<a href="https://zhuanlan.zhihu.com/p/30008641">https://zhuanlan.zhihu.com/p/30008641</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='poofAlgorithm.html'>共识算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15353572275978.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15353571670713.html">
                
                  <h1>股份证明机制(POS)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='poofAlgorithm.html'>共识算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15353571670713.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15350288973049.html">
                
                  <h1>分布式共识算法思考</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15350288973049.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348504281449.html">
                
                  <h1>比特币的开发环境配置</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348504281449.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348479167262.html">
                
                  <h1>区块链技术学习指引</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>本文为文章的索引，小白必看，有新的文章会自动更新，建议大家加入收藏夹中，如果觉得本站不错，欢迎转发给你朋友。</p>

<h2 id="toc_0">引言</h2>

<blockquote>
<p>给真正想学习区块链技术的同学一个指引，区块链技术随比特币而诞生，因此首先要了解比特币。<br/>
随着区块链技术的发展，基于以太坊的DApp智能合约，Hyperledger的超级账本，国内的FISOS的金链盟等技术平台的成熟呈现出了多元化，使得区块链应用进入了快速车道。</p>
</blockquote>

<h2 id="toc_1">比特币</h2>

<p>如果你还不知道比特币是什么，那就看看什么是比特币</p>

<h2 id="toc_2">比特币基础入门</h2>

<p>接下来可以通过下面的几片文章了解，比特币大概的运行原理</p>

<ul>
<li>  什么是比特币 </li>
<li>  区块链的基本概念<br/>
通过这篇可了解到钱包，哈希，加密，交易，块，默克尔树，挖矿，网络，区块链</li>
<li>  区块链交易本质 </li>
<li>  比特币的脚本</li>
<li>  什么是挖矿</li>
<li>  p2p网络</li>
<li>  其他相关的介绍</li>
<li>  比特币的开发环境配置</li>
</ul>

<h2 id="toc_3">比特币进阶</h2>

<p>在基础入门之后，可进一步阅读以下文章，可以系统的了解比特币是如何运转的，脚本系统的智能合约雏型，以及更多的共识算法</p>

<ul>
<li>  一片完整比特币转账交易的文章</li>
<li>  脚本系统的智能合约雏型</li>
<li>  主流的共识算法</li>
</ul>

<h2 id="toc_4">比特币应用案例分析</h2>

<ul>
<li>  押金证明实现</li>
<li>  跨链交易</li>
<li>  众筹案例</li>
</ul>

<h2 id="toc_5">以太坊</h2>

<p>一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上，去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。</p>

<ul>
<li>  以太坊开发入门</li>
<li>  智能合约开发环境搭建及hello world合约</li>
<li>  搭建智能合约开发环境Remix IDE及使用</li>
<li>  以太坊客户端Geth命令用法</li>
<li>  Geth控制台使用实践及web3.js使用</li>
<li>  如何搭建以太坊私有链</li>
</ul>

<h2 id="toc_6">智能合约及应用开发</h2>

<ul>
<li>  一步步教你开发，部署第一个Dapp应用</li>
<li>  创建自己的数据货币，进行ICO</li>
<li>  实现一个可管理，增发，兑换，冻结等高级工功能等代币</li>
<li>  如何通过以太坊智能合约进行众筹</li>
<li>  web3与智能合约的交互实战</li>
<li>  web3监听合约事件</li>
<li>  如何编写一个可升级的智能合约</li>
<li>  美链BEC合约漏洞技术分析<br/></li>
</ul>

<h2 id="toc_7">Solidity语言教程</h2>

<p>Solidity语言是开发智能合约最广泛的语言，本专栏应该是国内最深度介绍Solidity的文章了。</p>

<ul>
<li>  Solidity 教程系列1 - 类型介绍</li>
<li>  Solidity 教程系列2 - 地址类型介绍</li>
<li>  Solidity 教程系列3 - 函数类型介绍</li>
<li>  Solidity 教程系列4 - 数据存储位置分析</li>
<li>  Solidity 教程系列5 - 数组介绍</li>
<li>  Solidity 教程系列6 - 结构体与映射</li>
<li>  Solidity 教程系列7 - 以太单位及时间单位</li>
<li>  Solidity 教程系列8 - Solidity API</li>
<li>  Solidity 教程系列9 - 错误处理</li>
<li>  Solidity 教程系列10 - 完全理解函数修改器</li>
<li>  Solidity 教程系列11 - 视图函数、虚函数讲解</li>
<li>  Solidity 教程系列12 - 库的使用</li>
<li>  Solidity 教程系列13 - 函数调用</li>
<li>  智能合约最佳实践 之 Solidity 编码规范</li>
<li>  如何理解以太坊ABI - 应用程序二进制接口</li>
</ul>

<h2 id="toc_8">以太坊线上DApp分析</h2>

<h2 id="toc_9">FISOS金链盟</h2>

<ul>
<li>  什么是金链盟</li>
<li>  FISOS环境搭建</li>
</ul>

<h2 id="toc_10">更多实惠付费内容</h2>

<pre><code class="language-text">我建立的一个区块链学习的问答及交流的社区：知识星球《宋培众对区块链的理解》，大家学习过程中遇到的问题可以在星球里提，提问不限于博客文章的内容。同时星友还有一个专属的微信技术交流群方便大家及时的沟通。
目前知识星球问答社区定价199，有需要加入的同学请加：spzhong

宋培众对区块链的理解 - 系统学习区块链，打造最好的区块链技术博客。
</code></pre>

<h2 id="toc_11">参考文献</h2>

<p>官方文档-函数</p>

<p>欢迎来知识星球提问，星球内已经聚集了300多位区块链技术爱好者。<br/>
深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客<br/>
<center><br/>
<img src="media/15348479167262/531534842234_.pic_hd.jpg" alt="531534842234_.pic_hd"/><br/>
宋培众 wechat<br>微信号：区块链技术，欢迎订阅<br/>
<br></center>               </p>

<blockquote>
<p>本文作者： 宋培众<br/>
本文链接： https://暂无<br/>
版权声明： 本文采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='index.html'>指引</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348479167262.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348479167321.html">
                
                  <h1>比特币</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>概述：从别从，比特币的发展历史，，，，，，</p>

<hr/>

<h3 id="toc_0">历史</h3>

<ul>
<li>2008年，Bitcoin是由署名Satoshi Nakamoto发明的，他出版了为“Bitcoin:A Peer-to-Peer Electronic Cash System”;结合了b-money和hashCash的发明，创建一个完全去中心化的电子现金系统，不依赖中央机构进行的货币发行或结算和验证交易。</li>
<li>2009年，基于中本聪（传言是澳大利亚人，目前尚未被确认身份）发布的参考实施指南，之后由许多程序员进行修订。</li>
<li>2014年，比特币背后的区块链技术被大家关注，并正式的发布分布式记账本（Distributed Ledger）技术的革新浪潮。</li>
</ul>

<hr/>

<h3 id="toc_1">什么是比特币</h3>

<p>本质上就是一个去中心化账本<br/>
一种建立于p2p和密码学基础上的数据货币<br/>
密码学和分布式系统的组合产物<br/>
比特币的特点：</p>

<ul>
<li>去中心化的点对点网络<br/>
比特币的传输协议，或者是说脚本的传输协议</li>
<li>区块链<br/>
存放交易的数据链 <br/>
块，时间戳，难度系数，交易集合</li>
<li>共识机制<br/>
货币的发行规则（是一种奖励规则，解决货币的流通的问题）<br/>
交易的验证规则（交易引用，解决交易双花问题）<br/>
交易数据一致性（去中心化，引入工作量证明，解决由谁来写入区块链的问题） <br/>
脚本的网络传输协议（解决个个节点之间的区块同步问题） </li>
<li>货币所有权的证明<br/>
公钥，私钥，匿名化交易</li>
</ul>

<hr/>

<h3 id="toc_2">比特币是如何发行的</h3>

<p>比特币没有特定的发行机构，而是依靠一套去中心化的发行机制，逐步将比特币发行出去；比特币系统相当于一个去中心化的大账本，每个区块就是这一个账本中的一页，系统自动生成比特币作为奖励激励矿工参与记账；<br/>
每十分钟全体矿工一起计算一道问题，最先算出的矿工获得记一页账的权利，经过100个块确认后，矿工将自动的获得一定数量的比特币；<br/>
最开始记账一次获取50个比特币，每记21万页账（大约需要4年）记账的奖励就会减少一半，直到大约2140年，比特币无法细分，直至发行完毕，总量2100万枚；</p>

<hr/>

<h3 id="toc_3">什么是比特币的钱包</h3>

<p>比特币的钱包是存放用户的私钥和公钥的；和现实的钱包不太一样</p>

<h5 id="toc_4">1.密码学的基础</h5>

<ul>
<li><p>哈希运算<br/>
又称为散列函数，把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值</p>
<blockquote>
<p>f（x）不可逆，只能正向运算<br/>
    极难找到hash值相同的<br/>
    正向运算快，即时原文很大<br/>
    无论原文多大，都压缩固定位数的16进制</p>
</blockquote></li>
<li><p>非对称加密<br/>
密钥是一对，拥有公开密钥和私有密钥，随机生成一个私钥，然后通过椭圆曲线算法得到公钥</p>
<blockquote>
<p>公钥加密，只有私钥可解开<br/>
    私钥签名，可以用公钥验证</p>
</blockquote></li>
<li><p>base58和base58cheack<br/>
为了更简洁的表示长串的数字，使用更少的符号来表示<br/>
比特币钱包的地址<br/>
比特币钱包的验证</p></li>
</ul>

<h5 id="toc_5">2.钱包都有哪些类型</h5>

<ul>
<li>全节点钱包客户端</li>
<li>简单支付验证客户端SPV</li>
<li>基于第三方客户端程序接口</li>
</ul>

<h5 id="toc_6">3.生成自己的钱包</h5>

<blockquote>
<p>私钥，随机32位字符（256位随机数）<br/>
公钥，椭圆曲线加密SECP2561算法<br/>
公钥哈希值，SHA256(公钥)<br/>
公钥哈希值，ripemd160(公钥哈希值)<br/>
校验码，SHA256(SHA256(1个字节版本号0x00+公钥哈希值))，取前4个字节<br/>
base58(1个字节版本号0x00+公钥哈希值+校验码)<br/>
得到钱包地址</p>
</blockquote>

<h3 id="toc_7">比特币怎么完成交易的</h3>

<p>比特币系统雨传统的银行支付系统不同，是基于去中心化的信任，在比特币中取代了中央信任机构，信任通过各个节点之间的互相参与互相达成的； </p>

<ol>
<li><p>交易的概述</p>
<p>在比特币系统中由用户（通过私钥控制的钱包），将每一笔的交易广播到整个比特币的网络中，矿工通过竞争计算生成的每个节点达成的共识的区块（包含当前网络中所发生的所有的交易），然后将其区块同步到其它的节点；</p>
<p>比特币的持有者已授权把比特币转账给其他人，而持有者能够再次授权，转移给该比特币所有权链中的其他人，产生另一笔交易来花掉这些比特币，后面的持有者在花费比特币也是类似的方式；</p>
<p>整个交易的传递，其实就是所有权的证明转移，这就是为什么说，区块链实现的是价值的转移，而非单纯互联网信息传递；</p></li>
<li><p>块，交易结构己交易链的说明</p></li>
</ol>

<pre><code class="language-text"># pram 块的结构
type Block struct {
        hash               string       哈希
        confirmations      string       确认次数
        size               uint64       块的大小
        height             uint64       块的高度
        version            uint32       块的版本
        merkleroot         string       默克尔树（后期讲解）
        tx                 []           交易的详细信息集合
        time               uint32       块的时间
        nonce              uint32       随机数（最大2^32，后期讲解）
        bits               string       当前目标hash值
        difficulty         float64      难度系数（用于挖矿控制，后期讲解）
        previousblockhash  string       上一个区块的hash
}
 
# pram 交易的结构
type tx struct {
        hex                 string              交易的十六进制
        txid                string              交易的id
        version             uint64              版本号
        locktime            uint64              锁定时间（后期在脚本中会讲解）
        vin                 []                  交易的输入
        vout                []                  交易的输出
        blockhash           string              所在的块的hash
        confirmations       uint32              交易确认的次数
        time                uint32              交易的时间
        blocktime           uint32              所在快的时间
}

# pram 交易的输入（挖矿所得的币）结构
type vin_coinbase struct {
        coinbase            string              挖矿所得的备注说明
        sequence            uint32              序列
}

# pram 交易的输入（交易所得的币）结构
type vin_tx struct {
        txid                string             交易的id
        vout                uint32             交易的索引（和vout中的n对应）
        sequence            uint32             输入序列（后期在脚本中会讲解）
        scriptSig           map                解锁脚本
        {   
            asm =&gt; &quot;私钥签名&quot;,
            hex =&gt; &quot;16进制&quot;
        }
}

# pram 交易的输出结构
type vout struct {
        value               uint32           交易金额
        n                   uint32           交易引用索引           
        scriptPubKey        map              锁定脚本 
        {
            asm =&gt; &quot;脚本code&quot;,
            hex =&gt; &quot;签名验证16进制&quot;,
            reqSigs =&gt; &quot;签名个数，默认至少为1&quot;,
            type =&gt; &quot;pubkey:公钥验证，pubkeyhash:私钥签名验证&quot;,
            addresses =&gt; [&quot;钱包的地址&quot;]
        }                 
}
</code></pre>

<ol>
<li><p>首先如何获得第一个比特币</p>
<p>挖矿得到basecoin<br/>
场外交易</p></li>
<li><p>怎么计算余额</p>
<p>假设自己的钱包是全节点的客户端；</p>
<blockquote>
<p>得到自己的钱包地址</p>
</blockquote>
<p>遍历所有的区块，得到区块中的所有交易的输出 <br/>
匹配交易里面包含addresses字段，是一个数组结构（具体交易结构在交易细节中查看）<br/>
得到当前钱包地址匹配出来的交易，然后，在当前块中，查询是否有交易的输入包含该txid<br/>
如果没有包含，就加入未花费的交易(UTXO)的HashMap集合中<br/>
累加所有的未花费的交易(UTXO)的值，得到钱包中的余额</p>
<p>优化建议：</p>
<p><code>生成钱包时候，指定位数标记当前最大的区块高度（或时间戳）<br/>
    例如钱包的格式：1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA[37676/1535624845]<br/>
</code> </p>
<p>未花费的交易(UTXO)<br/>
交易没有被引用</p></li>
<li><p>怎么转账</p>
<p>组合UTXO，大于交易的金额</p></li>
<li><p>如何找零</p>
<p>将剩下的钱，转入自己的钱包中</p></li>
<li><p>交易费用</p>
<p>交易的小费是按照字节大小来计算的</p></li>
<li><p>完整交易的输入和输出</p>
<p>例如，用户a转账10个比特币给用户b<br/>
任何交易都有上一个交易的引用，或是说有多个输入或多个输出；</p>
<p>a用户给b用户转账的交易明细如下：<br/>
<strong>输入：</strong>解锁脚本(私钥验证签名)</p>
<blockquote>
<p>[<br/>
    a用户用自己的私钥，验证签名得到未花费的交易1,<br/>
    a用户用自己的私钥，验证签名得到未花费的交易2<br/>
]</p>
</blockquote>
<p><strong>输出：</strong>锁定脚本（转出公钥证明）</p>
<blockquote>
<p>[<br/>
    目标b用户的公钥，<br/>
    目标a用户的公钥（用于找零）<br/>
]</p>
</blockquote></li>
<li><p>交易的传输</p></li>
<li><p>交易的验证</p></li>
<li><p>挖矿写入区块链中</p></li>
<li><p>最终如何确认交易完成</p></li>
<li><p>b如何花费该笔交易</p></li>
</ol>

<h3 id="toc_8">交易的细节讲解</h3>

<p>生活中我们都有自己的银行账户，转账是在银行账户之间进行的。同样，比特币转账就是把比特币从一个比特币地址转移到另一个比特币地址上的过程。如果你想要转账比特币给别人，你需要在比特币交易平台、比特币钱包或者比特币客户端中，输入你的比特币地址、接收方地址、转账金额和手续费金额。确定支付后交易信息会在比特币网络进行全网广播。矿工每隔10分钟会将比特币网络中未被记账的交易打包进一个区块，这就完成了一次确认，此时比特币已转到对方账户。通常需要经过6次确认，确保交易记录不能被任何人窜改，转账才算真正完成。</p>

<ol>
<li><p>块的数据结构</p></li>
<li><p>交易的数据结构</p></li>
<li><p>交易费</p></li>
<li><p>如何找零</p></li>
<li><p>一个完整的交易例子说明</p></li>
</ol>

<h3 id="toc_9">挖矿的细节讲解</h3>

<p>挖矿是数字货币一个创新，解决了数据一致性的问题；<br/>
比特币通过挖矿产生，每10分钟，全网矿工一起计算一道算术题，谁先算出答案，就相当于挖到了这个区块，这个过程叫做挖矿；<br/>
那么是什么样的算术题呢？<br/>
首先，每个区块上有一难度系数，将随机产生hash256的值进行计算，需要小于该难度系数；<br/>
将交易信息+自增长的数字，进行hash256，得到64位的16进制，转换为二进制2<sup>256次方的值；</sup><br/>
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>
这是一个极大的值，例如随机产生一个2<sup>256次方的值都小于该值；</sup><br/>
为了增加计算的时间，我们将值缩小，例如：0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>
1 Khash/s = 1000 hash/s<br/>
1 Mhash/s = 1000 Khash/s<br/>
1 Ghash/s = 1000 Mhash/s<br/>
1 Shash/s = 1000 Ghash/s<br/>
1 PHash/s = 1000 Shash/s = 1000000000000000 hash/s <br/>
难度系数：<br/>
0x0000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>
nonce的最大值2<sup>32次方</sup><br/>
比特币里nonce的预设太小了。对于现在的挖矿难度，当交易的merkle tree给定后，在32bit的nonce里面找到解的概率忽略不计。一台专业矿机在秒为单位的时间内就能穷举完nonce的所有可能。nonce太小，Merkle tree root来凑。现在的做法是不断的改变coinbase交易，带动merkle tree变化，再循环穷举nonce。针对一个给定的merkle tree root，nonce穷举完了，还没找到解，接着改coinbase来换新的merkle tree root，开始新的nonce穷举，如此重复，直到找到解为止。<br/>
如何改变coinbase交易？<br/>
1000笔交易的顺序可能有，1000!个阶乘计算，这个数字是极其大的<br/>
预留了2<sup>32次方,那么最大的值是2<sup>224次方</sup></sup><br/>
<code>D*2^32/600<br/>
时间=难度*2^32/算力<br/>
</code> <br/>
随着运算的提高，难度系统也再增加，每2014块（两周）会调整一下，难度系数，确保产生的块平均维持在10分钟左右，不至于过快的将币挖完；</p>

<h3 id="toc_10">比特币的脚本讲解</h3>

<h3 id="toc_11">比特币的p2p网络</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348479167321.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15348479167538.html">
                
                  <h1>区块链的基本概念</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">定义</h3>

<pre><code class="language-text">分布式的数据库
密码学和分布式系统的组合产物
基于共识机制，去中心化的公开数据库
</code></pre>

<h3 id="toc_1">特点</h3>

<ul>
<li><p>分布式（Distributed）</p></li>
<li><p>自治的（Autonomous）</p></li>
<li><p>按照合约执行的（Contractual）</p></li>
<li><p>可追溯的（Trackable）</p></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='bit.html'>比特币</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      
                        <a href="15348479167538.html#disqus_thread">comments</a>
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>我对区块链的理解</h1>
                <div class="site-des">对区块链的思考</div>
                <div class="social">







<a target="_blank" class="weibo" href="https://weibo.com" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:spzhongwin@google.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="poofAlgorithm.html"><strong>共识算法</strong></a>
        
            <a href="about.html"><strong>关于</strong></a>
        
            <a href="index.html"><strong>指引</strong></a>
        
            <a href="bit.html"><strong>比特币</strong></a>
        
            <a href="ethereum.html"><strong>以太坊</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15385342635688.html">以太坊虚拟机</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15365050797831.html">一篇对数字签名的理解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15360563845824.html">关于</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358586085164.html">一篇对比特币的应用案例分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15358585289735.html">一篇对比特币网络的理解</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2018
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>


<script type="text/javascript">
    var disqus_shortname = 'coderforart'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'coderforart'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
