<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  一篇对比特币网络的理解 - 我对区块链的理解
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="我对区块链的理解" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>

<link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermaid.css">
<!--        <link rel="stylesheet" type="text/css" href="asset/sample-custom-html-charts/mermadidstyle.css">-->
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/jquery.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/rawdeflate.js"></script>
            <script type="text/javascript" src="asset/sample-custom-html-charts/jquery_plantuml/encode64.js"></script>
            <script src="asset/sample-custom-html-charts/echarts.common.min.js"></script>
            <script src="asset/sample-custom-html-charts/mermaid.min.js"></script>
            <script type="text/javascript">
                $(function(){
                  var mwebii=0;
                  var mwebChartEleId = 'mweb-chart-ele-';
                  $('pre>code').each(function(){
                                     mwebii++;
                                     var eleiid = mwebChartEleId+mwebii;
                                     if($(this).hasClass('language-mermaid')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div id="'+eleiid+'"></div>').addClass('mermaid').html($(this).text()).insertAfter(ele);
                                     }else if($(this).hasClass('language-plantuml')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     var str = unescape(encodeURIComponent($(this).text()));
                                     var imgURL = "http://www.plantuml.com/plantuml/svg/"+encode64(deflate(str,9));
                                     var newEle = $('<div id="'+eleiid+'"><img src="'+imgURL+'" /></div>').insertAfter(ele);
                                     }else if($(this).hasClass('language-js-echarts')){
                                     var ele = $(this).addClass('nohighlight').parent();
                                     ele.hide();
                                     $('<div style="width: 100%;height:400px;" id="'+eleiid+'"></div>').insertAfter(ele);
                                     var myChart = echarts.init(document.getElementById(eleiid));
                                     try  {
                                     eval($(this).text());
                                     myChart.setOption(option);
                                     }catch(exception) {}
                                     }
                                     });
                  
                  mermaid.init({noteMargin: 10}, ".mermaid");
                  });
                </script>



  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">首页</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        <li id=""><a target="_self" href="about.html">关于</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 我对区块链的理解</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">首页</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        
        <li><a target="_self" href="about.html">关于</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="about.html">关于</a></li>
        
            <li><a href="bit.html">比特币</a></li>
        
            <li><a href="ethereum.html">以太坊</a></li>
        
            <li><a href="poofAlgorithm.html">共识算法</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>一篇对比特币网络的理解</h1>
     
        <div class="read-more clearfix">
          <span class="date">2018/9/2</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='bit.html'>比特币</a></span>
           
         
          <span class="comments">
            
              <a href="15358585289735.html#disqus_thread">comments</a>
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <ul>
<li>
<a href="#toc_0">1.P2P网络架构</a>
</li>
<li>
<a href="#toc_1">2.节点类型及角色</a>
</li>
<li>
<a href="#toc_2">3.扩展比特币网络</a>
</li>
<li>
<a href="#toc_3">4.比特币传播网络</a>
</li>
<li>
<a href="#toc_4">5.网络发现</a>
<ul>
<li>
<a href="#toc_5">p2p握手协议</a>
</li>
<li>
<a href="#toc_6">新节点如何找到对等体</a>
</li>
<li>
<a href="#toc_7">建立连接后地址的传播和发现</a>
</li>
<li>
<a href="#toc_8">异常连接</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">6.全节点</a>
</li>
<li>
<a href="#toc_10">7.交换“库存清单”</a>
</li>
<li>
<a href="#toc_11">8.P2P的连接到数据同步</a>
</li>
<li>
<a href="#toc_12">9.简易支付验证(SPV)节点</a>
<ul>
<li>
<a href="#toc_13">什么是SPV</a>
</li>
<li>
<a href="#toc_14">SPV技术原理</a>
</li>
<li>
<a href="#toc_15">如何验证支付交易</a>
</li>
<li>
<a href="#toc_16">SPV如何实现？</a>
</li>
<li>
<a href="#toc_17">引入SPV节点带来的风险</a>
</li>
<li>
<a href="#toc_18">如何解决引入SPV的风险</a>
</li>
</ul>
</li>
<li>
<a href="#toc_19">10.Bloom过滤器</a>
<ul>
<li>
<a href="#toc_20">什么是Bloom过滤器</a>
</li>
<li>
<a href="#toc_21">Bloom过滤器是如何工作的</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">11.SPV节点如何使用Bloom过滤器</a>
</li>
<li>
<a href="#toc_23">12.SPV节点和隐私</a>
</li>
<li>
<a href="#toc_24">13.加密和认证连接</a>
<ul>
<li>
<a href="#toc_25">Tor网络传输</a>
</li>
<li>
<a href="#toc_26">对等认证和加密</a>
</li>
</ul>
</li>
<li>
<a href="#toc_27">14.交易池</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">DOS攻击（扩展阅读）</a>
<ul>
<li>
<a href="#toc_29">TCP三次握手</a>
</li>
<li>
<a href="#toc_30">常见的DOS攻击的方式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_31">布隆过滤器的应用与实现(扩展阅读)</a>


<h2 id="toc_0">1.P2P网络架构</h2>

<p>P2P是指同一网络中的美态计算机都彼此对等，各个节点共同提供网络服务，每个网络节点以&quot;扁平(flat)&quot;的拓扑结构互相连通</p>

<p>P2P网络节点之间交互运作，协同处理，每个节点在对外提供服务的同时也是使用网络中其它节点提供的服务</p>

<p>对于比特币设计的一种点对点数字现金系统，它的网络架构即反应出其特性，通过维持一种扁平化网路共识，来实现去中心化的交易系统</p>

<p>“比特币网络”是按照比特币P2P协议运行的一系列节点的集合，除了比特币协议之外，比特币网络中也包含其它的协议<br/>
例如Stratum协议，就被应用于挖矿，以及轻量级或移动端的比特币钱包中。网关（gateway）路由服务器提供的这些服务协议</p>

<blockquote>
<p>例如：Stratum服务器通过Stratum协议将所有的Stratum挖矿节点连接至比特币主网络，并将Stratum协议桥连接(bridge)至比特币p2p协议之上</p>
</blockquote>

<p>我们所说的比特币网络是指“比特币P2P协议”，“矿池挖矿协议”，“Stratum协议”以及其它连接比特币系统组件相关协议的整体网络机构</p>

<h2 id="toc_1">2.节点类型及角色</h2>

<p>一个比特币全节点是有“路由”，“区块链数据库”，“挖矿”，“钱包”组成；</p>

<ul>
<li>标准客户端 </li>
<li>全部数据块节点 </li>
<li>仅挖矿 </li>
<li>轻量级钱包SPV</li>
<li>协议池服务</li>
<li>挖矿节点</li>
<li>轻量的底层钱包</li>
</ul>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Wallet</td>
<td>Miner</td>
<td rowspan=2>【标准客户端】<br>包含一个钱包，挖矿，全部的区块数据，p2p的网络路由节点</td>
</tr>
<tr>
<td>Block</td>
<td>NetWork</td>
</tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>--</td>
<td>--</td>
<td rowspan=2> 【全部数据块节点】<br>包含全部的区块数据，p2p的网络路由节点 </td>
</tr>
<tr>
<td>Block</td>
<td>NetWork</td></tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>--</td>
<td>Miner</td>
<td rowspan=2>【仅挖矿】<br>包含一挖矿，全部的区块数据，p2p的网络路由节点</td>
</tr>
<tr>
<td>Block</td>
<td>NetWork</td></tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Wallet</td>
<td>--</td>
<td rowspan=2> 【轻量级钱包SPV】<br>包含钱包，p2p的网络路由节点 </td>
</tr>
<tr>
<td>--</td>
<td>NetWork</td></tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Pool Server</td>
<td>Stratum Server</td>
<td>【协议池服务】<br> 网关路由器将比特币P2P网络连接到运行其他协议的节点，例如矿池挖掘节点或层节点</td>
</tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Miner</td>
<td>Miner</td>
<td rowspan=2> 【挖矿节点】<br> 包含一个挖矿的功能，没有区块链，包含一个底层协议节点或其它挖矿池的协议节点 </td>
</tr>
<tr>
<td>Stratum node</td>
<td>Pool node</td>
</tr>
</table>

<table style = "text-align:center">
<tr>
<td colspan=2>节点角色</td>
<td>描述</td>
</tr>
<tr>
<td>Wallet</td>
<td>--</td>
<td rowspan=2> 【轻量的底层钱包】<br> 包含一个钱包和一个底层协议的网络节点 </td>
</tr>
<tr>
<td>--</td>
<td>StratumNode</td></tr>
</table>

<h2 id="toc_2">3.扩展比特币网络</h2>

<p>这张复杂的网路架构图我还没有仔细的分析？<br/>
<img src="media/15358585289735/135734wtwzoomwgbf2a4zb.png" alt="135734wtwzoomwgbf2a4zb"/></p>

<h2 id="toc_3">4.比特币传播网络</h2>

<p>比特币传播网络涉及到了底层网络架构的传输优化（建议了解即可）</p>

<p>比特币网络传播是一种尝试最新小化矿工之间的传输块的延迟网络</p>

<ol>
<li><p>为了延迟矿工之间快速同步块，该网络由世界各地的亚马逊web服务基础架构上托管的几个专门的节点，并且连接大多数矿工和采矿池</p></li>
<li><p>2016年比特币传播网络被替换成“Fast Internet Bitcoin Replay Engine”(FIBRE)</p></li>
<li><p>FIBRE是一种基于UDP的中继网络，可以中继节点网络内的块，FIBRE也是实现了compact(紧凑) block，进一步减少了传输的数据量和网络延迟</p></li>
<li><p>还有一个提案阶段中继网络是Falcon，使用“直通路由”而不是“存储转发”来减少延迟，通过传播块的部分，而不是等待知道接受到完成的块</p></li>
</ol>

<blockquote>
<p>补充一下什么是中继<br/>
中继（Relay）是连个交换中心之间的一条传输通路，中继线是承载多条逻辑链路的一条物理连接<br/>
在中继的无线系统中，每个用户只是在呼叫时才分配一个信道，一旦通过终止，原先占用的信道就立即回到可用信道库中</p>
</blockquote>

<pre><code class="language-text">物理层中继系统：转发器。
数据链路层中继系统：网桥
网络层中继系统：路由器
在网络层以上的中继系统称为网关，网关就是连接两备个网络的设备
</code></pre>

<p>无线路由器中继与桥接模式的区别？</p>

<p>中继模式，就是利用无线路由器之间的无线连接功能，将无线信号从一个中继点传递到下一个中继点，实现信号的增强，并形成新的无线覆盖区域，最终达到延伸无线网络的覆盖范围的目的。事实上，只要有两台支持中继功能的无线路由器，即可拓展网络覆盖范围。</p>

<p>中继和桥接功能对于无线用户的实际使用基本上是一样的，只是设备有所不同，并非所有无线路由器都可以桥接，无线路由桥接就是把无线路由器当中继器使用。桥接并非无线路由器的主要功能。使用中继模式时，网络SSID号均一致，而在桥接模式时，网络SSID号不同。</p>

<h2 id="toc_4">5.网络发现</h2>

<h3 id="toc_5">p2p握手协议</h3>

<p>当新的网络节点启动后，为了能够参与协同运作，必须发现网络中的其他比特币节点；<br/>
由于比特币网络的拓扑结构并不基于节点间的地理位置，因此各个节点之间的地理位置信息完全无关，会随机的选择网络中存在的比特币节点与之相连</p>

<p>节点通常采用了TCP协议，通常使用8333端口与已知的对等节点建立连接，在建立连接的时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通讯</p>

<pre><code class="language-javascript">version:{
    nVsersion:定义客户端所采用的比特币p2p协议的版本
    nLocalServices:[
        一组该节点支持的本地服务列表，当前仅支持NOED_NETWORK
    ]
    nTime:当前时间
    addrYou:当前节点可见的远程节点的IP地址
    addrMe:本地节点所发现的本机IP地址
    subver:指示当前节点运行的软件类型子版本号（例如：&quot;/Satoshi:0.9.2.1/&quot;）
    baseHeight:当前节点区块链的区块高度
}
</code></pre>

<p>版本信息始终是任何对等发送给另一个对等的第一条消息，接收版本消息的本地对等将检查远程对等体报告的nVersion，并确定远端对是否兼容，如果兼容则本地等将确认版本消息，并发送一个（ver）ack建立连接</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant a as NodeA
    participant b as NodeB
opt 节点A请求连接节点B
    a--&gt;&gt;b: 节点A的version
    b--&gt;&gt;b: 验证节点A的version
    b-&gt;&gt;a: 发送verack
end  
opt 节点B请求连接节点A
    b--&gt;&gt;a: 节点B的version
    a--&gt;&gt;a: 验证节点A的version
    a-&gt;&gt;b: 发送verack
end  
</code></pre>

<h3 id="toc_6">新节点如何找到对等体</h3>

<ol>
<li>使用多个“DNS种子”来查询DNS，这些DNS服务器提供比特币节点的IP地址列表，其中一些DNS种子提供了稳定的比特币侦听节点的静态IP地址列表，还有一些DNS种子是BIND，它从搜索器或长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集，在BitcoinCore客户端中，使用DNS种子的选项switch-dnsseed控制（默认设置为1，以使用DNS种子）</li>
<li>不知道网络的引导节点必须被给予至少一个比特币节点的IP地址，之后可以通过进一步来建立连接，命令参数-sendnode可用于连接到一个节点，仅用于将其作为种子</li>
</ol>

<h3 id="toc_7">建立连接后地址的传播和发现</h3>

<p>当建立一个或者多个连接后，新节点将一条包含自身的ip地址列表的addr消息发送给其它相邻的节点，相邻的节点再将此条addr消息依次转发给其它各自相邻的节点，从而保证新节点信息被多个节点接收，保证连接更稳定；<br/>
同时，新接入的节点可以向相邻节点发送getaddr消息，要求他们返回已知的对等节点的ip地址列表</p>

<p>由于节点可以随时的加入和离开，通讯路径是不可靠的，因此节点必须持续进行两项工作：在失去已有连接时发现新的节点，并在其他节点启动时为其提供帮助</p>

<p>一个节点无需连接大量的对等节点，在启动完成后，节点会记住它最新连接成功的对等节点，因此，当重新启动后它迅速与先前的对等节点网络重新建立连接，如果先前的网络无应答，则该节点可以使用种子节点进行重启动</p>

<p>bitcoin-cli getpeerInfo</p>

<pre><code class="language-javascript">{
    &quot;services&quot; : &quot;00000001&quot;,
    &quot;lastsend&quot; : 1405634126,
    &quot;lastrecv&quot; : 1405634127,
    &quot;bytessent&quot; : 23487651,
    &quot;bytesrecv&quot; : 138679099,
    &quot;conntime&quot; : 1405021768,
    &quot;pingtime&quot; : 0.00000000,
    &quot;version&quot; : 70002,
    &quot;subver&quot; : &quot;/Satoshi:0.9.2.1/&quot;,
    &quot;inbound&quot; : false,
    &quot;startingheight&quot; : 310131,
    &quot;banscore&quot; : 0,
    &quot;syncnode&quot; : true
},
{
    &quot;addr&quot; : &quot;58.23.244.20:8333&quot;,
    &quot;services&quot; : &quot;00000001&quot;,
    &quot;lastsend&quot; : 1405634127,
    &quot;lastrecv&quot; : 1405634124,
    &quot;bytessent&quot; : 4460918,
    &quot;bytesrecv&quot; : 8903575,
    &quot;conntime&quot; : 1405559628,
    &quot;pingtime&quot; : 0.00000000,
    &quot;version&quot; : 70001,
    &quot;subver&quot; : &quot;/Satoshi:0.8.6/&quot;,
    &quot;inbound&quot; : false,
    &quot;startingheight&quot; : 311074,
    &quot;banscore&quot; : 0,
    &quot;syncnode&quot; : false
  }
</code></pre>

<h3 id="toc_8">异常连接</h3>

<p>如果已建立的连接没有数据通信，所在的节点会定期发送信息以维持连接，如果节点持续某个连接长达90分钟没有任何的通信，它会被认为从网络中断开，因此，比特币网络会随时根据变化的节点及网络问题进行动态的调整，无需经过中心化的控制即可进行规模增减的有机调整</p>

<h2 id="toc_9">6.全节点</h2>

<p>全节点是指维持包含全部交易信息的完整区块链的节点，又称“完整区块链节点”，在比特币早起，所有的节点都是全节点；</p>

<p>完整区块链节点，从创始块到网络最新的区块，它可以独立自主的校验任何交易的信息</p>

<p>无需借助任何其他系统，就可以完全摆脱中心化管理，获得完全的独立自由</p>

<p>它的代价就是，需要大量的存储空间和内存空间</p>

<h2 id="toc_10">7.交换“库存清单”</h2>

<p>一个全节点连接到对等节点之后，第一件事要做就是构建完整的区块链，如果该节点不包含如何区块链信息，那么新节点需要从创始块开始的数十万块的全部内容下载到新的节点上；</p>

<p>同步区块的过程中从发送的version消息开始，上面包含区块链的高度（区块的数量），对等节点门会叫唤一个getBlocks消息，其中包含他们本地区块链顶端的哈希值，比较其顶端的区块可得到那个节点区块链更长</p>

<p>较长的节点会给短的节点发送invx（inventory库存）消息，将这些区块的哈希传播出去，缺少这些区块的节点便可以通过各自发送的getData消息请求得到全区块的信息</p>

<h2 id="toc_11">8.P2P的连接到数据同步</h2>

<p>首先，为了防止单个节点承受的压力，单个节点最多承受100个节点的对等网络连接</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant a as Node0
    participant b as Node1
    participant c as Node2
    participant d as ...
opt 1.互相握手ACK
    a--&gt;&gt;b: 节点的version
    b--&gt;&gt;b: 验证节点的version
    b-&gt;&gt;a: 发送verack
    c--&gt;&gt;d: 节点的version
    d--&gt;&gt;d: 验证节点的version
    d-&gt;&gt;c: 发送verack
end  

opt 2.􏱐􏴡􏱕􏱖􏲔􏱰􏲠􏱐􏴡􏱕􏱖􏲔􏱰􏲠互相传播地址
    a--&gt;&gt;b: 上报自己addr信息
    a--&gt;&gt;b: 获取节点getaddr信息
    a--&gt;&gt;d: 上报自己addr信息
    a--&gt;&gt;d: 获取节点getaddr信息
    d--&gt;&gt;c: 上报自己addr信息
    d--&gt;&gt;c: 获取节点getaddr信息
end

opt 3.互相􏱐􏴡􏱕􏱖􏲔􏱰􏲠􏱐􏴡􏱕􏱖􏲔􏱰􏲠同步区块
    a--&gt;&gt;b: 获取getblocks顶端区块的HASH值
    b--&gt;&gt;a: 获取getblocks顶端区块的HASH值
    b--&gt;&gt;b: 验证两个区块的高度
    b-&gt;&gt;a: 发送inv（高于节点0,哈希值列表）
    a--&gt;&gt;b: 通过缺少的hash值getdata
    a--&gt;&gt;c: 通过缺少的hash值getdata
    a--&gt;&gt;d: 通过缺少的hash值getdata
end
</code></pre>

<h2 id="toc_12">9.简易支付验证(SPV)节点</h2>

<p>Simplified Payment Verification</p>

<h3 id="toc_13">什么是SPV</h3>

<p>并非所有的节点都有能力存储完整的区块链，例如智能电话，平板电脑，嵌入式系统等等，对于这些设备，通过简化的支付验证(SPV)的方式进行工作，也称为“轻量级客户端”</p>

<p>SPV节点只需要下载区块头，而不用下载包含每个区块中的交易信息，由此产生的区块链的大小时完成区块链的1/1000左右，SPV节点不能构建所有可可用于消费的UTXO的全貌，这是因为他们并不知道网络上所有的交易完整信息</p>

<blockquote>
<p>网上说一个例子，每个全节点就像是一个陌生城市里的游客，他带着一张包含每条街道，每个地址的详细地图，而SPV节点就像这个陌生城市里游客只知道一条主干道的名称，通过随机询问该城市中陌生人来获取分段的道路指示；</p>
</blockquote>

<h3 id="toc_14">SPV技术原理</h3>

<p>通过merklr_root_hash（验证区块中所有的交易真实性）<br/>
取出当前交易所在的区块hash，然后分别从不同的完整的区块节点对应的，默克尔树的叶子hash，然后计算得到根hash，再然后对比本地的区块头中根hash，从而验证了该交易的合法性</p>

<p>按照中本聪的原文，这里有个细节需要注意，SPV指的是“支付验证“，而不是“交易验证”。这两种验证有很大区别。</p>

<ul>
<li><p>“交易验证”非常复杂，涉及到验证是否有足够余额可供支出、是否存在双花、脚本能否通过等等，通常由运行完全节点的矿工来完成。</p></li>
<li><p>“支付验证”则比较简单，只判断用于“支付”的那笔交易是否已经被验证过，并得到了多少的算力保护（多少确认数）。</p></li>
</ul>

<h3 id="toc_15">如何验证支付交易</h3>

<p>简易支付验证是通过参考交易在区块链中的深度，而不是高度，来验证它们；<br/>
一个完整拥有区块链的节点会构造一条验证链，这个链条是由区块链按时间倒序一直追溯到创始块的及交易组成，然后SPV节点会验证所有的区块链（但不是所有的交易），并且把区块链和有关交易链接起来</p>

<p>例如，一个全节点要检查第1000000号区块中的某个交易，它会把从该区块开始一直追溯到创始块，将所有的区块都链接起来，并建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。SPV节点则不能验证UTXO是否还未支付，相反的SPV节点会在该交易信息和它所在的区块之间用merkle路径建立一条链接，然后SPV节点一直处于等待的状态，至到1000000+6个块写入区块上，并通过确立交易的深度是在1000000-1000006块之下验证交易的有效性</p>

<p>如果一个交易实际上不存在，SPV节点不会误认为该交易存在于某区块中，SPV节点会通过请求merkle路径证明以及验证区块链中的工作证明，来证实交易存性，不过，一个交易的存在是可能对SPV节点“隐藏”的，这个漏洞会针对SPV节点的拒绝服务攻击或双重支付攻击，为了防御这些攻击，SPV节点需要随机链接到多个节点，以增加与至少一个可靠节点相链接的概率；这种随机链接的需求就意味着容易受到网络的分区攻击或Sybil攻击，在Sybil攻击中SPV节点被连接到虚假节点或虚假网络中，没鱼哦通向可靠节点或真正的比特币网络的连接</p>

<blockquote>
<p>Sybil攻击（女巫攻击）<br/>
在对等网络中，单个节点通常具有多个身份标示，通过控制系统的大部分节点来消弱冗余备份的作用<br/>
女巫攻击是在P2P网络中，因为节点随时加入退出等原因，为了维持网络稳定，同一份数据通常需要备份到多个分布式节点上，这就是数据冗余机制。女巫攻击是攻击数据冗余机制的一种有效手段。如果网络中存在一个恶意节点，那么同一个恶意节点可以具有多重身份，那么恶意节点比它还能分。这一分可好，原来需要备份到多个节点的数据被欺骗地备份到了同一个恶意节点（该恶意节点伪装成多重身份），这就是女巫攻击</p>
</blockquote>

<pre><code class="language-解决sybil攻击的方法有">1.工作量证明机制，即证明你是一个节点，是要用计算能力证明，这样极大地增加了攻击的成本
2.身份认证（基于第三方的身份认证和随机密钥分发验证的公钥体制的认证方式）
FISOS金链盟就是用，随机密钥分发验证的公钥体制的认证方式
</code></pre>

<h3 id="toc_16">SPV如何实现？</h3>

<pre><code class="language-mermaid">    graph TB
    根HASH --&gt; 区块全节点1
    根HASH --&gt; 区块全节点2
    区块全节点1 --&gt; 区块全节点3
    区块全节点1 --&gt; 区块全节点4
    区块全节点2 --&gt; 区块全节点5
    区块全节点2 --&gt; 区块全节点6
    区块全节点3 --&gt; 区块全节点7
    区块全节点3 --&gt; 区块全节点8
    区块全节点4 --&gt; 区块全节点9
    区块全节点4 --&gt; 区块全节点10 
    区块全节点5 --&gt; 区块全节点11
    区块全节点5 --&gt; 区块全节点12 
    区块全节点6 --&gt; 区块全节点13
    区块全节点6 --&gt; 区块全节点14 
    区块全节点7 --&gt; 第1笔交易的HASH
    区块全节点8 --&gt; 第2笔交易的HASH
    区块全节点9 --&gt; 第3笔交易的HASH
    区块全节点10 --&gt; 第4笔交易的HASH
    区块全节点11 --&gt; 第5笔交易的HASH
    区块全节点12 --&gt; 第6笔交易的HASH
    区块全节点13 --&gt; 第7笔交易的HASH
    区块全节点14 --&gt; 第7笔交易的HASH
    end  
</code></pre>

<p>如果想验证第一笔交易，那么需要查询节点8，节点4，节点2对应当前块所在的叶子节点的HASH</p>

<p>同理如果想验证第四笔交易，哪些需要查询节点9，节点3，节点2对应当前块所在的叶子节点的HASH</p>

<p>再然后，通过查询到的叶子节点的HASH，进行默克尔二叉树HASH运算，得到根HASH</p>

<h3 id="toc_17">引入SPV节点带来的风险</h3>

<p>隐私风险<br/>
SPV节点对特定数据的请求会无意中透漏了钱包里的地址信息，监控网络的第三方可以跟踪某个SPV节点上的钱包所请求的全部信息，并且利用交易信息把比特币地址和钱包用户关联起来，从而损害了用户的隐私</p>

<h3 id="toc_18">如何解决引入SPV的风险</h3>

<p>Bloom过滤器<br/>
通过一个采用概率而不是固定模式过滤的机制，允许SPV节点只接收交易信息的子集，同时不会精准的泄漏哪些它们的感兴趣的地址<br/>
接下来会深入的讲解Bloom过滤器</p>

<h2 id="toc_19">10.Bloom过滤器</h2>

<h3 id="toc_20">什么是Bloom过滤器</h3>

<p>是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法<br/>
它让用户在有效搜索关键词的同时保护了他们的隐私，这个方法解决了对等节点发送交易信息查询请求，同时交易的地址也不会暴露</p>

<p>之前一个陌生人到陌生城市找线路的例子，当陌生人询问“教堂23号在哪里”，其实不经意间暴露了自己的目的地，Bloom过滤器则是这样询问的，附近带有“堂”字的街道吗？或是以“堂”结尾或是以“教”开头的街道</p>

<h3 id="toc_21">Bloom过滤器是如何工作的</h3>

<p>实现的原理：由一个可变长度(N)的二进制数组（N位进制树构成的一个位域）和数量可变的(M)的一组哈希函数组成；<br/>
这些哈希函数的输出值始终在1和N之间，该数组与二进制数组相对对应，该函数位确定函数，也就是说任何一个使用相同Bloom过滤器的节点通过该函数能对特定输入得到同一个结果；Blomm过滤器的准确性和私密性通过改变长度(N)和哈希数量(M)来调节</p>

<p>位数组和k散列函数<br/>
1.位数组<br/>
初始化状态，BloomFilter是一个长度位M的位数组，每一位都置为0<br/>
2.添加元素（k个独立的hash函数）<br/>
添加元素时，对x进行k个哈希函数得到的k个哈希值，对其进行M求余，对应的bit位设置为1<br/>
3.判断元素是否存在<br/>
判断y是否属于这个集合，对y使用k个哈希函数得到的k个哈希值，对M求余，所对应的位置都是1，则认为y属于该集合（可能存在误判），否则就认为y不属于该集合</p>

<p>BloomFilter（布隆过滤）算法   </p>

<pre><code class="language-text">已知参数列表如下：
m 位数组的长度
n 加入其中元素的数量
k 哈希函数的个数
f 错误率
</code></pre>

<p>公式( 1 - (1 - 1/m)<sup>kn</sup> )<sup>k</sup> ≈ (1 - e<sup>-kn/m</sup> )<sup>k</sup></p>

<p>加入m和n是固定的值的时候，能够使f最小化的k为<br/>
(m/n)ln(2) ≈ 9m/13n ≈ 0.7m/n</p>

<p>此时给出的f为<br/>
f = (1/2)<sup>k</sup> ≈ 0.6185<sup>m/n</sup></p>

<p>根据以上公式，对于任意给定的f<br/>
n = m ln(0.6185)/ln(f)</p>

<p>需要k个hash来达成目标<br/>
k = -ln(f)/ln(2)</p>

<p>由于k必须是整数，还应该使用上面的公私求得实际的错误率<br/>
f = (1-e<sup>-kn/m</sup> )<sup>k</sup></p>

<p>使用Hash函数的个数，位数组的大小来降低失误率。</p>

<h2 id="toc_22">11.SPV节点如何使用Bloom过滤器</h2>

<p>Bloom过滤器用于过滤SPV节点，从其对等接收的交易（和包括它们的块头），仅选择SPV节点感兴趣的交易，而不会泄漏其感兴趣的地址和密钥</p>

<p>SPV节点初始化“过滤器”为空，在该状态下，Bloom过滤器将不匹配任何模式，然后，SPV节点将列出所有感兴趣的地址，密钥和散列，它将通过从其钱包控制的任何UTXO中提取出公钥的哈希和脚本哈希和交易id来实现。SPV节点然后将其中的每一个添加到Bloom过滤器，以便如果这些模式存在于交易中，则Bloom过滤器将“匹配”，而不是自动显示模式</p>

<p>然后，SPV节点将向对等体发送一个过滤器加载消息，其中包含在连接上使用的Bloom过滤器，在对等体上，针对每个传入交易检查Bloom过滤器，完整节点根据Bloom过滤器检查交易的几部分，寻找匹配，包括（<br/>
    交易的id<br/>
    每个交易输出的锁定脚本的数据（脚本中的每个健和哈希）<br/>
    每个交易的输入<br/>
    每个输入签名数据<br/>
）通过检查所有这些组件，可以使用Bloom过滤来匹配公钥哈希，脚本，OP_RETURN值，签名中的公钥或智能合同或复杂脚本的任何未来组件</p>

<p>在建立过滤器之后，对等体然后将针对Bloom过滤器测试每个交易的输出，只有与过滤器，只有与过滤器匹配的交易才会发送到节点</p>

<p>响应于来自节点的getdata消息，对等体将发送一个merkeblock消息，该消息仅包含于过滤器匹配的块和每个匹配交易的merkle路径，然后，对等体还将发送包含由过滤器匹配的交易的tx消息</p>

<p>由于完整节点向SPV节点发送交易，SPV节点丢弃任何误报，并使用正确匹配的交易来更新其UTXO集和钱包余额，随着更新自己的UTXO集视图，它还会修改Bloom过滤器，以匹配任何引用其刚刚发现的UTXO的交易，然后，完整节点使用新的bloom过滤器来匹配新的交易，并重复整个过程</p>

<p>设置bloom过滤器的节点可以通过发送filteradd消息将模式交互添加到过滤器中，要清楚bloom过滤器，节点可以发送一个过滤器清楚消息，因为不可能从布局过滤器中删除模式，所以如果不再需要模式，则节点必须清楚并重新发送新的BLoom过滤器</p>

<p>例如：SPV节点获取自己钱包中余额<br/>
SPV节点会以Bloom过滤器的形式告诉全节点的自己的地址信息，那么根据Bloom过滤器的特性，会有两种的结果：<br/>
1.没有通过Bloom过滤器过滤出来的UTXO，一定不属于钱包地址<br/>
2.通过Bloom过滤器过滤出来的UTXO，可能属于钱包地址<br/>
这种方法虽然一定程度上保护了用户的隐私，节省了存储空间和带宽，但是根据Bloom过滤器的特点，随着钱包交易的UTXO越多，Bloom过滤器误报率越高，也就是全节点返回正确的UTXO概率就越低</p>

<pre><code class="language-mermaid">    sequenceDiagram
    participant a as SPV节点
    participant b as 全节点
    opt Bloom Filter
    a --&gt;&gt; a : 钱包地址进行多次的hash计算
    a --&gt;&gt; a : 进行字节位的填充
    a --&gt;&gt; a : 得到Bloom Filter
    end
    a --&gt;&gt; b : 将Bloom Filter提交给全节点
    opt 模糊匹配
    b --&gt;&gt; b : 遍历所有的UTXO
    b --&gt;&gt; b : 寻找符合Bloom Filter的相关交易
    end
    b -&gt;&gt; a :  给节点所有可能相关UTXO
    a -&gt;&gt; a :  SPV节点匹配得到自己的UTXO
</code></pre>

<h2 id="toc_23">12.SPV节点和隐私</h2>

<p>SPV的节点隐私比整个节点更弱，SPV节点接收与其钱包中的地址相关的经过过滤的列表，所有说整体上减少了所有者的隐私。</p>

<p>Bloom过滤器是减少隐私损失的一种方式，即时使用过滤器，对手监控SPV客户端的流量或直接连接到它的P2P网络中的节点可以随时随地收集足够的信息来了解SPV客户端钱包中的地址</p>

<h2 id="toc_24">13.加密和认证连接</h2>

<p>比特币节点网络通讯是加密的，P2P网络隐私和安全性有两种方案Tor传输和P2P认证和加密</p>

<h3 id="toc_25">Tor网络传输</h3>

<p>Tor代表是洋葱路由网络，是一个软件项目和网络，通过提供匿名，不可追踪和隐私的随机网络路径提供数据的加密和封装</p>

<blockquote>
<p>洋葱路由器是一个类似于P2P原理的代理服务器，所有安装了洋葱路由的用户既是代理服务器的使用者也是代理服务器的提供者，洋葱路由器是由志愿者，花费自己的带宽建立起来的。</p>
</blockquote>

<h3 id="toc_26">对等认证和加密</h3>

<p>BIP-150提供了可选的对等认证，允许节点使用ECDSA和私钥对对方身份进行身份验证<br/>
BIP-151支持了两个节点之间的所有通信的协商加密<br/>
不过这两种方案目前还尚未在BicoinCore实施</p>

<p>BIP-150和BIP-151允许用户运行连接到受信任的完整节点的SPV客户端，使用加密和身份证来保护SPV客户端的隐私</p>

<h2 id="toc_27">14.交易池</h2>

<p>在比特币网络中几乎每一个节点都会维护一份未确认的交易的临时列表，他被称为内存池和交易池。<br/>
节点们利用这个池来追踪记录哪些被网络所知晓，但是还未被区块链所包含的交易；<br/>
例如，保存用户钱包的节点会利用这个交易池来记录哪些网络已经接收但还未被确认的，属于该用户钱包的预支付信息</p>

<p>随着交易被接收和验证，他们被添加到交易池并通知相邻节点处，从而传播到到网络中</p>

<p>有些节点的实现，还维护一个单独的孤立交易池，如果一个交易的输入与某未知的交易有关，如与缺失的夫交易相关，该孤立交易就会被暂时存储在孤立的交易池中至到父交易的信息到达</p>

<p>当一个交易被添加到交易池中，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出（子交易），任何匹配的孤立交易会被进行验证；如果验证有效，他们会从孤立交易池中删除，并添加到交易池中，使以其夫交易开始链变的完整；<br/>
对新加入交易池的交易来说，他不再是孤立交易，前述的过程重复递归寻找进一步的后代，知道所有的后代都被找到，通过这一个过程，一个父交易的到达把整个链中的孤立交易和它们的父交易重新结合再一起，从而触发了整条交易链进行级链重构</p>

<p>交易池和孤立交易池都是存储在本地内存中，并不是存储永久性存储设备，它是随网络传入的消息动态填充，节点启动时，两个池子都是空闲的，随着网络中新交易不断被接收，两个池逐渐被填充</p>

<p>有些客户端还维护一个UTXO数据库，也成为UTXO池，是区块链中所有为支付交易输出的集合，UTXO感觉与交易池相似，但它代表了不同的数据集，UTXO池不同与交易池和孤立交易池的地方，它在初始化时不为空，而是包含了数以百万计的为支付的交易输出条目，有些条目的历史可以追溯到2009年。UTXO池可能被安置在本地内存或者作为一个包含索引的数据库安置在永久性存储设备中</p>

<p>交易池和孤立交易池代表是单个节点的本地视角，取决于节点的启动时间或重启时间，不同的节点两个池内容可能有很大的差别，相反的，UTXO池代表是网络的突显共识，因此不同节点间的UTXO池的内容差别不大。此外，交易池和孤立交易池只包含未确认交易，而UTXO池只包含已确认的交易</p>

<h1 id="toc_28">DOS攻击（扩展阅读）</h1>

<p>Dos是一对一<br/>
DDos是分布式多个节点对抗一个节点</p>

<h2 id="toc_29">TCP三次握手</h2>

<p>完成三次握手，客户端于服务器开始传送数据</p>

<ul>
<li>第一次握手<br/>
建立连接时，客户端发送SYN(syn=j)包到服务器，并进入SYN_SENT状态，等待服务器确认 </li>
<li>第二次握手<br/>
服务器收到SYN包，必须确认客户的syn(ack=j+1),同时自己也发送一个SYN包（syn=k）,即syn+ack包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手<br/>
客户端收到服务器的SYN+ACK包，向服务器端发送确认ACK(ack=k+1),此包发送完毕，客户端和服务器进行ESTABLISHEN(TCP连接成功)状态</li>
</ul>

<blockquote>
<p>SYN:同步序列编号（Synchronize Sequence Numbers）  </p>
</blockquote>

<pre><code class="language-mermaid">sequenceDiagram
participant a as 客户主机
participant b as 服务器主机
a-&gt;&gt;b: 连接请求（SYN=1,seq=client_isn） 
b-&gt;&gt;a: 授予连接（SYN=1,seq=client_isn）\n ack=client_isn+1
a-&gt;&gt;b: 确认（SYN=0,seq=client_isn+1）\nack=server_isn+1
</code></pre>

<h2 id="toc_30">常见的DOS攻击的方式</h2>

<ol>
<li>SYN FLOOD<br/>
利用服务器的连接缓冲区，设置TCP的Header,向服务器不断的成倍的发送有SYN标志的TCP请求，当服务器收到的时候，都认为没有建立起来的连接请求，于是排队到缓冲区队列中</li>
<li>IP欺骗DOS攻击<br/>
这种攻击是利用RST位来实现，假设有一个合法的用户(1.1.1.1)已经同服务器建立了正常的连接，攻击者构造攻击的TCP数据，伪装自己的IP(1.1.1.1),并向服务器发送一个带有RST位的TCP数据段，服务器收到后会认为1.1.1.1连接有错误，就会清空缓冲区的建立好的连接</li>
<li>带宽DOS攻击<br/>
如果你的连接带宽足够大而服务器又不是很大，可以发送大量的请求，来消耗服务器的缓冲区消耗服务器的带款</li>
<li>自身消耗的DOS攻击<br/>
这种攻击的方式是利用了老式的系统（win95）自身的BUG,攻击者伪装成自己的服务器端的IP端口，发送给主机，使得主机给自己发送TCP请求和连接，至到把资源耗光</li>
<li>塞满服务器的硬盘<br/>
发送垃圾邮件（前提邮件服务器和WEB服务器放在一起）<br/>
日志记录爆满（入侵者构造大量的错误的信息发送出来）</li>
</ol>

<h1 id="toc_31">布隆过滤器的应用与实现(扩展阅读)</h1>

<p>在软件设计时，我们经常要判断一个元素是否在一个集合中。如：网络爬虫时，一个网址是否已经被访问过、一个邮件地址是否在黑名单中、在文字处理软件中某个英文单词是否拼写正确等。一个直接的方法是，将集合中的所有元素都存储在计算机中（如保存在链表、树、哈希表等数据结构）。当要判断一个新元素的时候，直接跟集合中的已存储元素对比即可判断元素是否在集合中。但是，当随着加入的数据量增加，我们需要存储元素的空间就越来越大，而且检索速度也会开始变慢。链表、树、哈希表的数据结构检索时间复杂度分别为：O(n)、O(logn)、O(n/k)。</p>

<p>举个例子，像Gmail这种邮件服务提供商，要过滤垃圾邮件。如果采用上面说的方法，将垃圾邮件加入到哈希表中，那至少要加入数十亿的垃圾邮件地址。没存储一个亿的email地址，就需要1.6GB（将一个email地址转换成一个8字节的信息指纹并存入到哈希表中。由于哈希表的存储效率一般只有50%，所以实际存储一个email地址需要16字节，一个亿的email地址就大概需要1.6GB的内存空间，如果存储几十亿的email地址，就可能需要几十上百的内存空间）。所以传统的存储方法要求要大量的存储空间。而采用布隆过滤器，它只需要哈希表的1/8或1/4的大小（也就是只需要200MB或400MB的空间）就可以解决问题。 </p>

<p>为什么说哈希表的存储效率一般只有50%</p>

<pre><code class="language-text">Hash Table 常用于频繁进行 key/value 模式的查找中。(查找模式，如匹配查找)  
哈希表最大的优点在于查找速度快，但存储时可能发生collision(冲突)。
哈希表大多使用open addressing来解决collision，此时search的时间复杂度计算公式为：
      1/( 1 - n/m )
其中，n与m分别表示存储的记录数与哈希表的长度，即装填因子( 
load factor)故，若哈希表半满，即 n/m &gt;= 1/2，则每次的search次数可能会 &gt;= 2 

 因此，为了保证Hash Table在 key/value 查找模式中的优势，一般，其存储效率不会超过50%。
</code></pre>

<p>布隆过滤器（Bloom Filter）python实现 </p>

<pre><code class="language-python"># -*- coding: utf-8 -*-
from pybloom import BloomFilter
# capacity是数据集容量大小（n）, error_rate是能容忍的误报率（P）
f = BloomFilter(capacity=1000,error_rate=0.001)
print f.add(‘dog’) # 当不存在该元素,返回False
print f.add(‘cat’) # 当不存在该元素,返回False
print f.add(‘fish’) # 当不存在该元素,返回False
print f.add(‘pig’) # 当不存在该元素,返回False
print f.add(‘cat’) # 若存在,返回 True
print len(f) # 当前存在的元素个数
</code></pre>

<p>具体参考</p>

<p><a href="http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html">布隆过滤器 (Bloom Filter) 详解</a></p>

<p><a href="https://blog.csdn.net/zdxiq000/article/details/57626464">大量数据去重：Bitmap和布隆过滤器(Bloom Filter)</a></p>

<p>可以使用JDK自带的BitSet来实现，但存在两个问题：OOM和持久化问题。<br/>
结合Redis的BitMap能够解决，唯一需要注意的是Redis的BitMap只支持2<sup>32</sup> 大小，对应到内存也就是512MB,数组的下标最大只能是2<sup>32-1</sup> 。不过这个限制可以通过构建多个Redis的Bitmap通过hash取模的方式分散一下即可。万分之一的误判率，512MB可以放下2亿条数据。<br/>
好了，扯了这么多，贴代码！(注：在MagnusS/Java-BloomFilter的基础上加上了Redis持久化的实现)</p>

<pre><code class="language-java">@Component
public class BloomFilter&lt;E&gt; {

    @Autowired
    private RedisTemplate&lt;String, E&gt; redisTemplate;

    @Value(&quot;${bloomfilter.expireDays}&quot;)
    private long expireDays;

    // total length of the Bloom filter
    private int sizeOfBloomFilter;
    // expected (maximum) number of elements to be added
    private int expectedNumberOfFilterElements;
    // number of hash functions
    private int numberOfHashFunctions;
    // encoding used for storing hash values as strings
    private final Charset charset = Charset.forName(&quot;UTF-8&quot;);
    // MD5 gives good enough accuracy in most circumstances. Change to SHA1 if it&#39;s needed
    private static final String hashName = &quot;MD5&quot;;
    private static final MessageDigest digestFunction;

    // The digest method is reused between instances
    static {
        MessageDigest tmp;
        try {
            tmp = java.security.MessageDigest.getInstance(hashName);
        } catch (NoSuchAlgorithmException e) {
            tmp = null;
        }
        digestFunction = tmp;
    }

    public BloomFilter() {
        this(0.0001, 600000);
    }

    /**
     * Constructs an empty Bloom filter.
     *
     * @param m is the total length of the Bloom filter.
     * @param n is the expected number of elements the filter will contain.
     * @param k is the number of hash functions used.
     */
    public BloomFilter(int m, int n, int k) {
        this.sizeOfBloomFilter = m;
        this.expectedNumberOfFilterElements = n;
        this.numberOfHashFunctions = k;
    }

    /**
     * Constructs an empty Bloom filter with a given false positive probability.
     * The size of bloom filter and the number of hash functions is estimated
     * to match the false positive probability.
     *
     * @param falsePositiveProbability is the desired false positive probability.
     * @param expectedNumberOfElements is the expected number of elements in the Bloom filter.
     */
    public BloomFilter(double falsePositiveProbability, int expectedNumberOfElements) {
        this((int) Math.ceil((int) Math.ceil(-(Math.log(falsePositiveProbability) / Math.log(2))) * expectedNumberOfElements / Math.log(2)), // m = ceil(kn/ln2)
                expectedNumberOfElements,
                (int) Math.ceil(-(Math.log(falsePositiveProbability) / Math.log(2)))); // k = ceil(-ln(f)/ln2)
    }

    /**
     * Adds an object to the Bloom filter. The output from the object&#39;s
     * toString() method is used as input to the hash functions.
     *
     * @param element is an element to register in the Bloom filter.
     */
    public void add(E element) {
        add(element.toString().getBytes(charset));
    }

    /**
     * Adds an array of bytes to the Bloom filter.
     *
     * @param bytes array of bytes to add to the Bloom filter.
     */
    public void add(byte[] bytes) {
        if (redisTemplate.opsForValue().get(RedisConsts.CRAWLER_BLOOMFILTER) == null) {
            redisTemplate.opsForValue().setBit(RedisConsts.CRAWLER_BLOOMFILTER, 0, false);
            redisTemplate.expire(RedisConsts.CRAWLER_BLOOMFILTER, expireDays, TimeUnit.DAYS);
        }

        int[] hashes = createHashes(bytes, numberOfHashFunctions);
        for (int hash : hashes) {
            redisTemplate.opsForValue().setBit(RedisConsts.CRAWLER_BLOOMFILTER, Math.abs(hash % sizeOfBloomFilter), true);
        }
    }

    /**
     * Adds all elements from a Collection to the Bloom filter.
     *
     * @param c Collection of elements.
     */
    public void addAll(Collection&lt;? extends E&gt; c) {
        for (E element : c) {
            add(element);
        }
    }

    /**
     * Returns true if the element could have been inserted into the Bloom filter.
     * Use getFalsePositiveProbability() to calculate the probability of this
     * being correct.
     *
     * @param element element to check.
     * @return true if the element could have been inserted into the Bloom filter.
     */
    public boolean contains(E element) {
        return contains(element.toString().getBytes(charset));
    }

    /**
     * Returns true if the array of bytes could have been inserted into the Bloom filter.
     * Use getFalsePositiveProbability() to calculate the probability of this
     * being correct.
     *
     * @param bytes array of bytes to check.
     * @return true if the array could have been inserted into the Bloom filter.
     */
    public boolean contains(byte[] bytes) {
        int[] hashes = createHashes(bytes, numberOfHashFunctions);
        for (int hash : hashes) {
            if (!redisTemplate.opsForValue().getBit(RedisConsts.CRAWLER_BLOOMFILTER, Math.abs(hash % sizeOfBloomFilter))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns true if all the elements of a Collection could have been inserted
     * into the Bloom filter. Use getFalsePositiveProbability() to calculate the
     * probability of this being correct.
     *
     * @param c elements to check.
     * @return true if all the elements in c could have been inserted into the Bloom filter.
     */
    public boolean containsAll(Collection&lt;? extends E&gt; c) {
        for (E element : c) {
            if (!contains(element)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Generates digests based on the contents of an array of bytes and splits the result into 4-byte int&#39;s and store them in an array. The
     * digest function is called until the required number of int&#39;s are produced. For each call to digest a salt
     * is prepended to the data. The salt is increased by 1 for each call.
     *
     * @param data   specifies input data.
     * @param hashes number of hashes/int&#39;s to produce.
     * @return array of int-sized hashes
     */
    public static int[] createHashes(byte[] data, int hashes) {
        int[] result = new int[hashes];

        int k = 0;
        byte salt = 0;
        while (k &lt; hashes) {
            byte[] digest;
            synchronized (digestFunction) {
                digestFunction.update(salt);
                salt++;
                digest = digestFunction.digest(data);
            }

            for (int i = 0; i &lt; digest.length / 4 &amp;&amp; k &lt; hashes; i++) {
                int h = 0;
                for (int j = (i * 4); j &lt; (i * 4) + 4; j++) {
                    h &lt;&lt;= 8;
                    h |= ((int) digest[j]) &amp; 0xFF;
                }
                result[k] = h;
                k++;
            }
        }
        return result;
    }

    public int getSizeOfBloomFilter() {
        return this.sizeOfBloomFilter;
    }

    public int getExpectedNumberOfElements() {
        return this.expectedNumberOfFilterElements;
    }

    public int getNumberOfHashFunctions() {
        return this.numberOfHashFunctions;
    }

    /**
     * Compares the contents of two instances to see if they are equal.
     *
     * @param obj is the object to compare to.
     * @return True if the contents of the objects are equal.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final BloomFilter&lt;E&gt; other = (BloomFilter&lt;E&gt;) obj;
        if (this.sizeOfBloomFilter != other.sizeOfBloomFilter) {
            return false;
        }
        if (this.expectedNumberOfFilterElements != other.expectedNumberOfFilterElements) {
            return false;
        }
        if (this.numberOfHashFunctions != other.numberOfHashFunctions) {
            return false;
        }
        return true;
    }

    /**
     * Calculates a hash code for this class.
     *
     * @return hash code representing the contents of an instance of this class.
     */
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 61 * hash + this.sizeOfBloomFilter;
        hash = 61 * hash + this.expectedNumberOfFilterElements;
        hash = 61 * hash + this.numberOfHashFunctions;
        return hash;
    }

    public static void main(String[] args) {
        BloomFilter&lt;String&gt; bloomFilter = new BloomFilter&lt;&gt;(0.0001, 600000);
        System.out.println(bloomFilter.getSizeOfBloomFilter());
        System.out.println(bloomFilter.getNumberOfHashFunctions());
    }
}
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15358586085164.html" 
          title="Previous Post: 一篇对比特币的应用案例分析">&laquo; 一篇对比特币的应用案例分析</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15358584946404.html" 
          title="Next Post: 一篇对比特币挖矿的理解">一篇对比特币挖矿的理解 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          
            <div id="disqus_thread"></div>
          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>我对区块链的理解</h1>
                <div class="site-des">对区块链的思考</div>
                <div class="social">







<a target="_blank" class="weibo" href="https://weibo.com" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:spzhongwin@google.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="about.html"><strong>关于</strong></a>
        
            <a href="bit.html"><strong>比特币</strong></a>
        
            <a href="ethereum.html"><strong>以太坊</strong></a>
        
            <a href="poofAlgorithm.html"><strong>共识算法</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15397582057010.html">一篇关于区块BerkeleyDB的存储</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15397440071875.html">一篇关于最新比特币技术的说明</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15396726640663.html">Raft</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15396726536666.html">Paxos</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15385342635688.html">以太坊虚拟机</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2018
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>


<script type="text/javascript">
    var disqus_shortname = 'coderforart'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'coderforart'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
